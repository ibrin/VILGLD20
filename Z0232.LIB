// 1-26-96, Allow transmitter to overflow receiver beyond CTS not ready.
// 7-13-95, compute 80% and 20% of buffer with float multiply.
/* START LIBRARY DESCRIPTION *********************************************
Z0232.LIB
    Copyright (c) 1994, Z-World.

DESCRIPTION:  Drivers for Z180 port 0. If port 0 is also used as the 
Dynamic C programming port, load the serial interrupt routine during run 
time as follows: (1) comment out "#INT_VEC SER0_VEC  Dz0_circ_int" (2) in 
the code, add the declaration "extern void Dz0_circ_int();"  and (3) load 
the routine with: "reload_vec(14, Dz0_circ_int);"  Depending on the 
application, it may be desireable to delay initialization of the serial 
port to make sure your hardware is connected. Or an external trigger from 
a keypad or input port could trigger the software to initialized the serial 
port.

SUPPORT LIB'S: modem232.lib, rtk.lib
END DESCRIPTION **********************************************************/


/*** Beginheader  Dinit_z0, Dwrite_z0, Dread_z0, Dkill_z0, Dwrite_z01ch,
                  Dread_z01ch, Dreset_z0tbuf, Dreset_z0rbuf, z0modemstat,
                  z0modemset, z0binaryset, z0binaryreset, Drestart_z0modem */

int  Dinit_z0(char *rbuf, char *tbuf, int rsize, int tsize,
     char mode, char baud, char ismodem, char isecho);
int  Dwrite_z0(char *buf, int count);     // initiate send
int  Dread_z0(char *buf, char terminate); // initiate receive
int  Dwrite_z01ch(char data);
int  Dread_z01ch(char *data);
void Dreset_z0tbuf(void);
void Dreset_z0rbuf(void);
void Dz0send_prompt(void);
void Drestart_z0modem(void);
void Dkill_z0(void);
int  Dz0modem_chk(char *buf);
void Dz0_circ_int(void);
int  z0modemstat(void);
int  z0modemset(void);
void z0binaryset(void);
void z0binaryreset(void);

/*** Endheader */

char *z0_write_buf;          // Static pointer to the transmit buffer
char *z0_read_buf;           // Static pointer to the receive buffer
shared int z0_rx_head;       // Head pointer for the receive buffer
shared int z0_rx_tail;       // Tail pointer for the receive buffer
shared int z0_tx_head;       // Head pointer for the transmit buffer
shared int z0_tx_tail;       // Tail pointer for the transmit buffer
int z0_rx_size;              // Static storage of receive buffer size
int z0_tx_size;              // Static storage of transmit buffer size
                             // if 1, in xmodem file xfer mode; else 0
shared int z0_80rbuf;
shared int z0_20rbuf;
shared int z0_rbufcnt;
shared int z0_tbufcnt;
char z0_CRTS_ENB;
char z0_CTS_ON;
char z0_echo;
char z0Binary;               // 1 if serial receive is in binary mode.
                             // 0 (default) if serial receive is in text mode.
char z0CmdOrData;            // 1 if modem is in command mode
char z0UseModem;             // 1 if using modem


/* START FUNCTION DESCRIPTION ********************************************
z0binaryset                  <Z0232.LIB>

SYNTAX: void z0binaryset(void);

DESCRIPTION: Sets serial communication mode to binary.  All receive data
are stuffed directly into the receive buffer.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug void z0binaryset(void)
{
    z0Binary = 1;
}

/* START FUNCTION DESCRIPTION ********************************************
z0binaryreset                <Z0232.LIB>

SYNTAX: void z0binaryreset(void);

DESCRIPTION: Resets serial communication to ASCII mode. Backspace char
is tracked to adjust the receive buffer head index.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug void z0binaryreset(void)
{
    z0Binary = 0;
}

/* START FUNCTION DESCRIPTION ********************************************
z0modemstat                  <Z0232.LIB>

SYNTAX: int z0modemstat(void);

DESCRIPTION: Returns the status of the modem.

RETURN VALUE: 1, if modem is in command mode; else 0, if modem in
data mode (i.e. open to communication).
END DESCRIPTION **********************************************************/
nodebug int z0modemstat(void)
{
    return (z0CmdOrData);
}

/* START FUNCTION DESCRIPTION ********************************************
z0modemset                   <Z0232.LIB>

SYNTAX: int z0modemset(void);

DESCRIPTION: Returns information about modem selection.

RETURN VALUE: 1, if modem option is selected; else 0.
END DESCRIPTION **********************************************************/
nodebug int z0modemset(void)
{
    return (z0UseModem);
}

/* START FUNCTION DESCRIPTION ********************************************
Dz0send_prompt               <Z0232.LIB>

SYNTAX: void Dz0send_prompt(void);

DESCRIPTION: Sends 'CR','LINEFEED' and '>' to Z180 channel 0.  Does not 
check for available space in the transmit buffer.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug void Dz0send_prompt(void)
{
    static char prompt[4] =
            {
                ENTER, LINEFEED, '>', '\0'
            };
    Dwrite_z0(prompt, 3);
}

/* START FUNCTION DESCRIPTION ********************************************
Dinit_z0                     <Z0232.LIB>

SYNTAX: int Dinit_z0(char *rbuf, char *tbuf, int rsize, int tsize, 
            char mode, char baud, char ismodem, char isecho);

DESCRIPTION: Initializes Z180 port 0 for serial communication. "rbuf" 
points to a user defined (receive) character array; "tbuf" points to a 
user defined (transmit) character array; "rsize" is the size of rbuf; 
"tsize" is the size of tbuf; "mode" is defined as follows: bit0 = 0 for 1 
stop bit, 1 for 2 stop bits;  bit1 = 0 for no parity, 1 for parity;
bit2 = 0 for 7 data bits, 1 for 8 data bits; bit3 = 0 for even parity, 
1 for odd; bit4 = 0/1 for CTS, RTS control disabled/enabled; "baud" is the 
baud rate in multiples of 1200 (e.g. 8 for 9600 baud). "ismodem" is 0, if 
no modem is used; 1, if modem is used. "isecho" is 0, if no char echoing; 
1 for automatic echoing.

RETURN VALUE: Return 1.
END DESCRIPTION **********************************************************/
nodebug int Dinit_z0(char *rbuf, char *tbuf, int rsize, int tsize,
            char mode, char baud, char ismodem, char isecho)
{
    z0Binary = 0;
    z0UseModem = ismodem;
    z0_echo    = isecho;
    z0_read_buf  = rbuf;      // initialize receive buffer
    z0_write_buf = tbuf;
    z0_rx_size = rsize;
    z0_tx_size = tsize;
    Dreset_z0tbuf();
    Dreset_z0rbuf();
    if (mode & '\B00010000') // CTS  and RTS ON
    {
        z0_CRTS_ENB = 1;
        z0_80rbuf = rsize * 0.80;   // 7-13-95 (rsize * 80) / 100;
        z0_20rbuf = rsize * 0.20;   // 7-13-95 (rsize * 20) / 100;
    }
    else 
        z0_CRTS_ENB = 0;

    z0_CTS_ON = 1;

    outport(STAT0, 0);       // reset port
    outport(CNTLB0, z180baud(sysclock(), baud) | ((mode << 1) & 0x10));
                             // set baud rate, odd or even parity
    outport(CNTLA0, (mode & 7));// set stop bits, etc. enb rts
    outport(CNTLA0, inport(CNTLA0) | 0x20);
    inport(RDR0);
    inport(RDR0);            // clear out reader registers
    outport(CNTLA0, inport(CNTLA0) | 0x40);// enable receiverr clear EFR
    outport(STAT0, inport(STAT0) | 8);// enable receiver interrupt
    if (z0UseModem)
        Drestart_z0modem();
    else 
        z0CmdOrData = 0;
    return 1;
}

/* START FUNCTION DESCRIPTION ********************************************
Dreset_z0rbuf                <Z0232.LIB>

Reset the receive buffer for the z180 channel 0.

SYNTAX: void Dreset_z0rbuf(void);

DESCRIPTION: Resets receive buffer for Z180 channel 0.  Sets head and 
tail indexes to zero.  Sets z0_rbufcnt to zero.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug void Dreset_z0rbuf(void)
{
    z0_rbufcnt = z0_rx_head = z0_rx_tail = 0;
}

/* START FUNCTION DESCRIPTION ********************************************
Dreset_z0tbuf                <Z0232.LIB>

SYNTAX: void Dreset_z0tbuf(void);

DESCRIPTION: Resets Z180 channel 0 transmit buffer. Sets head and 
tail indexes to zero.  Sets z0_tbufcnt to zero.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug void Dreset_z0tbuf(void)
{
    z0_tbufcnt = z0_tx_head = z0_tx_tail = 0;
}

/* START FUNCTION DESCRIPTION ********************************************
Dwrite_z0                    <Z0232.LIB>

SYNTAX: int Dwrite_z0(char *buf, int count);

DESCRIPTION: Writes character data array of length "count" to transmit 
buffer.  "buf" is pointer to character array.  "count" is number of char's 
to send.  Transmit interrupt is automatically turned on, if off.

RETURN VALUE: 1, if array is succesfully copied; 0, if there's no space 
in transmit buffer.
END DESCRIPTION **********************************************************/
nodebug int Dwrite_z0(char *buf, int count)
{
    int dum_tail, dum_head;
    int i;

    if (!count) 
        return 1;            // no need to write
    if ((z0_tbufcnt + count) >= z0_tx_size) 
        return 0;            // not enough space
    dum_head = z0_tx_head;
    i = 0;
    do
    {
        *(z0_write_buf + dum_head++) = *(buf + i++);
        if (dum_head == z0_tx_size) 
            dum_head = 0; 
    } while (i < count);
    DI();                   // disable interrupt, 5-3-94
    if (z0_tx_tail == z0_tx_head)
    {
        EI();               // enable interrupt, 5-3-94
        z0_tx_head = dum_head;
        z0_tbufcnt = count;  
        outport(STAT0, inport(STAT0) | 1);
                             // initiate transfer if not transferring
    }
    else
    {
        z0_tx_head = dum_head;
        z0_tbufcnt = z0_tbufcnt + count;
        EI();               // enable interrupt, 5-3-94
    }
    return 1;
}

/* START FUNCTION DESCRIPTION ********************************************
Dread_z0                     <Z0232.LIB>

SYNTAX: int Dread_z0(char *buf, char terminate);

DESCRIPTION: Reads serial receive buffer for stream with specified 
terminate character.  "buf" points to user defined character array.
"terminate" is the terminating character of the stream, which is replaced 
by '\0'.  If modem option is selected with Dinit_z0(...), receive 
stream is automatically parsed for modem messages.  The latter are 
automatically processed and the serial service routines are automatically 
called.  Note that modem messages are terminated with 'CR'.

RETURN VALUE: 1, if stream is found and copied to buf; 0, if no stream 
is found or if modem option is selected and stream matched a modem message.
END DESCRIPTION **********************************************************/
nodebug int Dread_z0(char *buf, char terminate)
{
    int i;
    int dum_head, dum_tail;
    
    dum_head = z0_rx_head;
    dum_tail = z0_rx_tail;
    i = 0;
    if (dum_head == dum_tail) 
        return 0;
    else
    {
        do
        {
            *(buf + i) = *(z0_read_buf + dum_tail++);
            if (dum_tail == z0_rx_size) 
                dum_tail = 0;          // Wrap around circ rec'v buffer.
            if (*(buf + i++) == terminate)
            {
                *(buf + i - 1) = '\0'; // Replace terminate char w '\0'
                // **** Service receive buffer ********
                z0_rx_tail = dum_tail; // Reset circ rec'v buffer tail.
                if (z0_CRTS_ENB)
                {
                    z0_rbufcnt = z0_rbufcnt - i;
                    if (! z0_CTS_ON)
                    {
                        if (z0_rbufcnt <= z0_20rbuf)
                        {
                            outport(CNTLA0, inport(CNTLA0) & '\B11101111');
                            z0_CTS_ON = 1;
                        }
                    }
                }
                if (z0UseModem)
                {
                    if (Dz0modem_chk(buf) == -1) 
                        return 1;        // Not a modem msg
                    else 
                        return 0;        // A modem msg
                }
                return 1;
            }
        } while (dum_tail != dum_head);  // 'til inbuf is empty
        return 0;
    }
}

/* START FUNCTION DESCRIPTION ********************************************
Dwrite_z01ch                 <Z0232.LIB>

SYNTAX: Dwrite_z01ch(char data);

DESCRIPTION: Writes a character to the transmit buffer.  Transmit 
interrupt is turned on, if off.

RETURN VALUE: 1, if data is succesfully written to transmit buffer;
0, if there's no space in buffer.
END DESCRIPTION **********************************************************/
nodebug int Dwrite_z01ch(char data)
{
    int dum_tail, dum_head;
    
    if ((z0_tbufcnt + 1) >= z0_tx_size) 
        return 0;
    dum_head = z0_tx_head;
    *(z0_write_buf + dum_head++) = data;
    if (dum_head == z0_tx_size) 
        dum_head = 0; 
    DI();                       // disable interrupt, 5-3-94
    if (z0_tx_tail == z0_tx_head)
    {
        EI();                   // enable interrupt, 5-3-94
        z0_tbufcnt = 1;
        z0_tx_head = dum_head;
        outport(STAT0, inport(STAT0) | 1);
                             // initiate transfer if not transferring
    }
    else
    {
        z0_tx_head = dum_head;
        z0_tbufcnt++;
        EI();                   // enable interrupt, 5-3-94
    }
    return 1;
}

/* START FUNCTION DESCRIPTION ********************************************
Dread_z01ch                  <Z0232.LIB>

SYNTAX: int Dread_z01ch(char *data);


DESCRIPTION: Reads serial receive buffer for a character.  "data" is 
pointer to a character.

RETURN VALUE: 1, if a byte is copied to *data; 0, if buffer is empty.
END DESCRIPTION **********************************************************/
nodebug int Dread_z01ch(char *data)
{
    int dum_head, dum_tail;

    dum_head = z0_rx_head;
    dum_tail = z0_rx_tail;
    if (dum_head == dum_tail) 
        return 0;
    else
    {
        *data = *(z0_read_buf + z0_rx_tail++);
        if (z0_rx_tail == z0_rx_size) 
            z0_rx_tail = 0; 
        if (z0_CRTS_ENB)
        {
            z0_rbufcnt--;
            if (!z0_CTS_ON)
            {
                if (z0_rbufcnt <= z0_20rbuf)
                {
                    outport(CNTLA0, inport(CNTLA0) & '\B11101111');
                    z0_CTS_ON = 1;
                }
            }
        }
        return 1;
    }
}

/* START FUNCTION DESCRIPTION ********************************************
Dkill_z0                     <Z0232.LIB>

SYNTAX: void Dkill_z0(void);

DESCRIPTION: Reset the Z180's channel 0.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug void Dkill_z0(void)
{
    outport(STAT0, 0);
}

/* START FUNCTION DESCRIPTION ********************************************
Drestart_z0modem             <Z0232.LIB>

SYNTAX: void Drestart_z0modem(void);

DESCRIPTION: Sends command to set/reset the modem connected to Z180, 
channel 0.  Hayes smart modem is desirable.  Required hardware 
connections:

                       MODEM               Z180 CHAN 0
                        RX  ----------------- TX
                        TX  ----------------- RX
                        GND ----------------- GND
                        RTS --+           +-- RTS
                        CTS --|           +-- CTS
                        DTR --+

i.e. On modem side, RTS,CTS and DTR are tied together.  On SCC side, 
RTS is connected to CTS.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug void Drestart_z0modem(void)
{
    int  ercode;
    int  ok_count;
    char buf[20];

    /* If modem is available, master should insure that modem
       is in command mode on power up                        */

    z0CmdOrData = 1;         // modem in command mode
    ok_count = 0;
    Dwrite_z0("+++", 3);
    Ddelay_1sec();
    while ((++ok_count < 4) && ((ercode = Dread_z0(buf, ENTER)) == 0 ||
           (Dget_modem_command(buf) != 0))) 
        Ddelay_1sec();

    Dwrite_z0("AT H0", 5);   // or time out
    Dwrite_z01ch(ENTER);
    ok_count = 0;
    while ((++ok_count < 4) && ((ercode = Dread_z0(buf, ENTER)) == 0 ||
           (Dget_modem_command(buf) != 0))) 
        Ddelay_1sec();       // Wait for OK

    Dwrite_z0("AT E0 V1 M0 S0=2", 16); // or time out
    /*****************************
     E0 for commands not echoed
     V1 for word responses
     M0 for internal speaker off
     S0=2 for automatic answering
     ******************************/
    Dwrite_z01ch(ENTER);
    ok_count = 0;
    while ((++ok_count < 4) && ((ercode = Dread_z0(buf, ENTER)) == 0 ||
           (Dget_modem_command(buf) != 0))) 
        Ddelay_1sec();       // Wait for OK
    
    Dwrite_z0("AT &D0 &R1", 10);// or time out
    /********************************************
     &D0 for ignore the Data Terminal Ready (DTR)
     &R1 for ignore the Ready To Send (RTS)
     ********************************************/
    Dwrite_z01ch(ENTER);
    ok_count = 0;
    while ((++ok_count < 4) && ((ercode = Dread_z0(buf, ENTER)) == 0 ||
           (Dget_modem_command(buf) != 0))) 
        Ddelay_1sec();       // Wait for OK
    
    Ddelay_1sec();
    Dreset_z0rbuf();
}

/* START FUNCTION DESCRIPTION ********************************************
Dz0modem_chk                 <Z0232.LIB>

SYNTAX: int Dz0modem_chk(char *buf);

DESCRIPTION: Checks 'CR' terminated stream for modem messages.  Serial 
service routines are called as function of the modem condition (if selected).
"buf" points to a 'CR' terminated stream that was copied from the receive 
buffer.

RETURN VALUE: -1, if no match to any modem messages; 0, if stream was 
processed as a modem message.
END DESCRIPTION **********************************************************/
nodebug int Dz0modem_chk(char *buf)
{
    int which_one;
    int i;
    int j;
    
    which_one = Dget_modem_command(buf);
    switch (which_one)
    {
        case - 1: 
            if (!z0CmdOrData) 
                return - 1;
            break;
        case 2:             // set for auto answer
                             // Dwrite_z0("ATA",3);
                             // Dwrite_z01ch(ENTER);
            break;           /* manually receive call if ring
                                is detected.                  */
        case 9:
            Ddelay_5sec();
            Ddelay_5sec();
            Dreset_z0tbuf();
            Dreset_z0rbuf();
            z0CmdOrData = 0;
            Dz0send_prompt();
            Dwrite_z0("Welcome to the Remote System", 28);
            Dz0send_prompt();
            break;
                             // connect at 2400 bps
                             // switch to data mode
        case 0:
            break;           // ok from command to modem
        case 3:
            z0CmdOrData = 1; // no carrier detect
            Ddelay_5sec();   // Wait and reset all buffers
            Dreset_z0tbuf();
            Dreset_z0rbuf();
            break;
        case 4:
            break;           // command error
        case 5:
            Ddelay_5sec();
            Ddelay_5sec();
            Dreset_z0tbuf();
            Dreset_z0rbuf();
            z0CmdOrData = 0;
            Dz0send_prompt();
            Dwrite_z0("Welcome to the Remote System", 28);
            Dz0send_prompt();
            break;           // switch to data mode
        case 6:             // no dial tone
        case 7:             // busy
        case 8:             // no answer
        case 10:            // just line feed
        default:
            break;
    }
    return 0;
}

/* START FUNCTION DESCRIPTION ********************************************
Dz0_circ_int                 <Z0232.LIB>

SYNTAX: Dz0_circ_int(void);

DESCRIPTION: Transmit and receive interrupt service routine for Z180 
chan 0.  For boards that use this port for programming, the vector should
be loaded during runtime.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
#if ROM==1
#INT_VEC SER0_VEC Dz0_circ_int // Set interrupt vector
#endif
// The preceding declaration makes this code romable.
#asm root nodebug
Dz0_circ_int::
        push af
        push hl
        push bc
        push de

        in0 a,(STAT0)
        bit 7,a
        jp z,_z0Txmit    ; not receiving, go to transmit

_z0Recvr:
        in0 c,(RDR0)      ; c has the character received
        in0 a,(CNTLA0)    ; reset error bit
        res 3,a
        out0 (CNTLA0),a

        ld a,(z0Binary)   ; binary mode ?
        cp 1
        jr z, _StuffData ; just stuff data in if binary mode.
                         ; if text mode, process the BACKSPACE character
        ld a,c
        cp BACKSPACE   ; is character a backspace
        jr nz, _notBackSpace
        ld a,(z0CmdOrData)
        cp 1
        jr z, _noEcho
        ld a,(z0_echo)
        cp 1
        jr nz,_noEcho
        out0 (TDR0),c    ; echo back the character

_noEcho:
        ld de,(z0_rx_tail)   ; see if (rx_head) == (rx_tail)
        ld hl,(z0_rx_head)
        ld a,d
        cp h               ;  if(rx_head)==(rx_tail)
        jr nz, _notHTR     ;
        ld a,e
        cp l
        jr nz, _notHTR
        jp _z0Txmit
_notHTR:
        ld a,h           ; if (rx_head)==0, (rx_head)=(rx_size) - 1;
        or l
        jr nz,_HeadnotZero
        ld hl,(z0_rx_size)
        dec hl
        ld (z0_rx_head),hl
        jp _decRbufcount

_HeadnotZero:
        ld hl,(z0_rx_head)  ; else (rx_head) = (rx_head) -1
        dec hl
        ld (z0_rx_head),hl
_decRbufcount:
        ld a,(z0_CRTS_ENB)
        cp 1
        jp nz, _z0Txmit
        ld hl, (z0_rbufcnt)
        dec hl
        ld (z0_rbufcnt),hl
        jp _z0Txmit

_notBackSpace:          ; not BACKSPACE, so push data into receive queue
        ld a,(z0CmdOrData)
        cp 1
        jr z, _StuffData
        ld a,(z0_echo)
        cp 1
        jr nz,_StuffData
        out0 (TDR0),c     ; echo character back
_StuffData:
; 1-26-96		  Allow transmitter to overflow beyond CTS not ready.
; 1-26-96        ld a,(z0_CTS_ON)
; 1-26-96        cp 1
; 1-26-96        jp nz,_z0Txmit
        ld de,(z0_read_buf)
        ld hl,(z0_rx_head)
        add hl,de
        ld (hl),c        ; store data
        ld de,(z0_rx_size)  ; do the modulo test
        ld hl,(z0_rx_head)
        inc hl
        ld a,d
        cp h             ; compare high byte
        jp nz,_notRollOver
        ld a,e
        cp l              ; compare low byte
        jp nz,_notRollOver
        ld hl,00
        ld (z0_rx_head),hl
        jp _checkforCTS
 _notRollOver:
        ld (z0_rx_head),hl
_checkforCTS:
        ld a,(z0_CRTS_ENB)
        cp 1
        jp nz, _z0Txmit
        ld hl, (z0_rbufcnt)
        inc hl
        ld (z0_rbufcnt),hl
        ld de, (z0_80rbuf)
        ld a,e
        cp l
        jp nz, _z0Txmit
        ld a,d
        cp h
        jp nz, _z0Txmit
        in0 a,(CNTLA0)
        set 4,a
        out0 (CNTLA0),a  ; make the rts0 line high
        ld a,0
        ld (z0_CTS_ON),a  ; software has to know too.
 _z0Txmit:
        in0 a,(STAT0)     ; is it a transmit interrupt?
        and 0x03
        xor 0x03
        jr nz, _z0TheEnd
        ld de,(z0_tx_head)   ; see if (tx_head) == (tx_tail)
        ld hl,(z0_tx_tail)
        ld a,d
        cp h        ; compare d to h
        jr nz, _notTxEnd
        ld a,e
        cp l
        jr nz, _notTxEnd
        in0 a,(STAT0)   ; turn off interrupt when no more char'a to send
        and 0xfe
        out0 (STAT0),a
        jp _z0TheEnd
 _notTxEnd:
        ld hl,(z0_tbufcnt)
        dec hl
        ld (z0_tbufcnt),hl
        ld de, (z0_write_buf)   ; send next character out
        ld hl, (z0_tx_tail)
        add hl,de
        ld c,(hl)
        out0 (TDR0),c
        ld de,(z0_tx_size)
        ld hl,(z0_tx_tail) ; do the modulo test
        inc hl
        ld a,d
        cp h             ; compare high byte
        jp nz,_notTRollOver
        ld a,e
        cp l
        jp nz,_notTRollOver
        ld hl,00
        ld (z0_tx_tail),hl
        jp _z0TheEnd
 _notTRollOver:
        ld (z0_tx_tail),hl
_z0TheEnd:
        pop de
        pop bc
        pop hl
        pop af
        ei
        ret
#endasm

/*** BeginHeader Dxmodem_z0down, Dxmodem_z0up */

int Dxmodem_z0down(char *mydata, int n_blocks);
int Dxmodem_z0up(unsigned long baseAddress, int *no_of_pages, int dest,
    int (*data_parsing)() );

/*** EndHeader */
extern char z0Binary;           // 12-15-94

/* START FUNCTION DESCRIPTION ********************************************
Dxmodem_z0down               <Z0232.LIB>

SYNTAX: int Dxmodem_z0down(char *mydata, int n_blocks);

DESCRIPTION: Sends blocks of data to PC or dumb terminal with xmodem 
file transfer protocol.  "mydata" points to a character array.  n_blocks 
is the size of the array in 128-byte blocks.

RETURN VALUE: 0, if there's a timeout during transfer; 1, if xfer 
was successful; 2, if xfer was cancelled.
END DESCRIPTION **********************************************************/
nodebug int Dxmodem_z0down(char *mydata, int n_blocks)
{
    int  i;
    int  timeout;
    unsigned char nth_block, not_nth;
    unsigned int testcrc;
    int  checksum;
    int  ercode;
    char cdata;
    int  iblock;

    nth_block = 1;
    not_nth = ~nth_block;

    z0Binary = 1;
    timeout = 0;
    Dwrite_z0("Ready to Download File", 22);
    Dz0send_prompt();
    Dwrite_z0("Do an xmodem receive", 20);
    Dz0send_prompt();
    while (((ercode = Dread_z01ch(&cdata)) == 0) || ((cdata != XCRC) && 
            (cdata != ESC) && (cdata != CAN) )  )
    {
        Ddelay_1sec();
        if (++timeout >= 30)
        {
            z0Binary = 0;
            Ddelay_5sec();
            return 0;
        }
    }
    if (cdata == CAN || cdata == ESC)// monitor for a quick ABORT
    {
        z0Binary = 0;
        Ddelay_5sec();
        return 2;
    }
    else 
        timeout = 0;

    do
    {
        iblock = (nth_block - 1) * 128;
        Dwrite_z01ch(SOH);
        Dwrite_z01ch(nth_block);
        Dwrite_z01ch(not_nth);
        Dwrite_z0(mydata + iblock, 128);
        testcrc = getcrc(mydata + iblock, 128, 0);
        cdata = (testcrc >> 8) & 0xff;
        Dwrite_z01ch(cdata);
        cdata = (testcrc & 0xff);
        Dwrite_z01ch(cdata);
        timeout = 0;
        while (((ercode = Dread_z01ch(&cdata)) == 0) ||
                ((cdata != XCRC) && (cdata != NAK) && (cdata != ACK) && 
                 (cdata != CAN)) )
        {
            Ddelay_1tick();
            if (++timeout > 200)
            {
                z0Binary = 0;
                Ddelay_5sec();
                return 0;
            }
        }
        if (cdata == CAN)
        {
            z0Binary = 0;
            Ddelay_5sec();
            return 2;
        }
        else if (cdata == ACK)
        {
            if (++nth_block <= n_blocks) 
                not_nth = ~nth_block;
            else
            {
                Dwrite_z01ch(EOT);
                timeout = 0;
                while (((ercode = Dread_z01ch(&cdata)) == 0) || 
                         cdata != ACK)
                {
                    Ddelay_1tick();
                    if (++timeout > 200)
                    {
                        z0Binary = 0;
                        Ddelay_5sec();
                        return 0;
                    }
                };
                // Wait for final acknowledge for end of transfer
                // time out if necessary
                z0Binary = 0;
                Ddelay_5sec();
                return 1;    // 1 for succesful transfer
            }
        }
    } while (1);
}

/* START FUNCTION DESCRIPTION ********************************************
Dxmodem_z0up                 <Z0232.LIB>


SYNTAX: int Dxmodem_z0up(unsigned long baseAddress, int *no_of_pages, 
            int dest, int (*data_parsing)() );

DESCRIPTION: Uploads data from a PC using the xmodem file transfer protocol.
"baseAddress" is the destination's physical ram address.  "*no_of_pages" is 
the size of the uploaded file in number of pages.  "dest" is an additional 
parameter to locate the uploaded file.  "*data_parsing" is the address of 
the function to parse the uploaded file into memory.  The required parsing 
function prototype is:

int parse_function(char *mydata, int blockcount, 
    unsigned long baseAddress, int dest);

where "mydata" points to a 128 byte block of data;  "blockcount" is 
the nth block;  "baseAddress" is the base address of the uploaded file;  and
"dest" is an added parameter to locate the data.  The parser function should 
return 1 for successful copy or else 0.

RETURN VALUE: 0, if there's a timeout during transfer; 1, if transfer 
was successful; 2, if transfer was cancelled.
END DESCRIPTION **********************************************************/
nodebug int Dxmodem_z0up(unsigned long baseAddress, int *no_of_pages, 
            int dest, int (*data_parsing)() )
{
    int  i;
    unsigned char nth_block, not_nth;
    unsigned int testcrc;
    unsigned int myblockcount;
    int  checksum;
    int  ercode;
    int  timeout;
    char cdata;
    char locrc, hicrc, mylocrc, myhicrc;
    static char mydata[130];

    myblockcount = 1;
    z0Binary     = 1;
    timeout      = 0;
    Dwrite_z0("Ready to receive", 16);
    Dz0send_prompt();
    Dwrite_z0("Xmodem File Up", 14);
    Dz0send_prompt();
    do
    {
        Dwrite_z01ch(XCRC);
        Ddelay_1sec();
        if (++timeout >= 30)
        {
            z0Binary = 0;
            Ddelay_5sec();
            return 0;
        }
    }
    while (((ercode = Dread_z01ch(&cdata)) == 0) || ((cdata != SOH) &&
            (cdata != ESC) && (cdata != CAN)));
    if (cdata == CAN || cdata == ESC) // somehow cancelled
    {
        z0Binary = 0;
        Ddelay_5sec();
        return 2;
    }
    do
    {
        timeout = 0;
        while (++timeout < 100 && (ercode = Dread_z01ch(&cdata) == 0)) 
            Ddelay_1tick();

        if (timeout >= 100)
        {
            z0Binary = 0;
            Ddelay_5sec();
            return 0;
        }
        else 
            nth_block = cdata;

        timeout = 0;
        while (++timeout < 100 && (ercode = Dread_z01ch(&cdata) == 0)) 
            Ddelay_1tick();

        if (timeout >= 100)
        {
            z0Binary = 0;
            Ddelay_5sec();
            return 0;
        }
        else 
            not_nth = cdata;

        checksum = 0;
        timeout = 0;
        for (i = 0; i < 128; i++)
        {
            while (++timeout < 100 && (ercode = Dread_z01ch(&cdata)) == 0) 
                Ddelay_1tick();

            if (timeout >= 100)
            {
                z0Binary = 0;
                Ddelay_5sec();
                return 0;
            }
            else
            {
                timeout = 0;
                mydata[i] = cdata;
            }
        }
        testcrc = getcrc(mydata, 128, 0);
        myhicrc = (testcrc >> 8) & 0xff;
        mylocrc = testcrc & 0xff;

        timeout = 0;
        while (++timeout <= 100 && (ercode = Dread_z01ch(&cdata) == 0)) 
            Ddelay_1tick();

        if (timeout >= 100)
        {
            z0Binary = 0;
            Ddelay_5sec();
            return 0;
        }
        else 
            hicrc = cdata;

        timeout = 0;
        while (++timeout <= 100 && (ercode = Dread_z01ch(&cdata) == 0)) 
            Ddelay_1tick();

        if (timeout >= 100)
        {
            z0Binary = 0;
            Ddelay_5sec();
            return 0;
        }
        else
        {
            if (cdata == mylocrc && hicrc == myhicrc)
            {
                if ((*data_parsing)(mydata, myblockcount, baseAddress, 
                dest) == 1)
                {
                    Dwrite_z01ch(ACK);
                    ++myblockcount;
                }
                else 
                    Dwrite_z01ch(XCRC); // use  Dwrite_z01ch(NAK) for chksum;
            }
            else 
                Dwrite_z01ch(XCRC); // use Dwrite_z01ch(NAK) for checksum;
        }
        timeout = 0;
        while (((ercode = Dread_z01ch(&cdata)) == 0) ||
                ((cdata != EOT) && (cdata != SOH) && (cdata != CAN)))
        {
            Ddelay_1tick();
            if (++timeout > 100) // Time out after ~2-3 seconds
            {
                z0Binary = 0;
                Ddelay_5sec();
                return 0;
            }
        }
        if (cdata == EOT)
        {
            Dwrite_z01ch(ACK);
            z0Binary = 0;
            *no_of_pages = myblockcount / 32;
            Ddelay_5sec();
            return 1;        // 1 for successful transfer
        }
        if (cdata == CAN)
        {
            z0Binary = 0;
            Ddelay_5sec();
            return 2;
        }
    } while (1);
}


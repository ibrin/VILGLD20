/* START LIBRARY DESCRIPTION *********************************************
KDM.LIB
    Copyright (c) 1994, Z-World.

DESCRIPTION: Software drivers for KDM keypads, Text LCD, Graphics LCD, and 
beeper. Timer driver that drives the keypad and the beeper also drives the 
real time kernel, when RUNKERNEL is defined.

SUPPORT LIB'S: sys.lib, drivers.lib
END DESCRIPTION **********************************************************/

/*** BeginHeader */

#ifndef __KDM_LIB
#define __KDM_LIB

#ifdef __CPLC_LIB
#error "KDM.LIB cannot be used with CPLC.LIB"
#endif

/*** EndHeader */

/*** BeginHeader lk_keytestr, lk_kxkey, lk_kxdead, lk_kxbuf, lk_kxinptr,
						lk_kxoutptr, lk_beepcount, lk_timecnt, lk_keyshadow,
						lk_usetab, lk_tab, lk_24tab, lk_16tab */



extern char lk_keytestr, lk_kxkey, lk_kxdead;
extern char lk_kxbuf[16], lk_kxinptr, lk_kxoutptr; // keystroke buffer
extern int  lk_beepcount;              // count of cycles on beeper
extern shared unsigned int lk_timecnt; // counted down every tick when not zero
extern char lk_keyshadow;              // shadow for key register
extern char lk_usetab;                 // tell to use table if not 24 keys


extern int lk_tab[41];              // to hold key codes

extern int lk_24tab[24];

extern int lk_16tab[16];

/*** EndHeader */

char lk_keytestr, lk_kxkey, lk_kxdead;
char lk_kxbuf[16], lk_kxinptr, lk_kxoutptr; // keystroke buffer
int  lk_beepcount;              // count of cycles on beeper
shared unsigned int lk_timecnt; // counted down every tick when not zero
char lk_keyshadow;              // shadow for key register
char lk_usetab;                 // tell to use table if not 24 keys

int lk_tab[41];              // to hold key codes

int lk_24tab[] =
{
    14, 22, 30, 38, 9,  17, 25, 33, 13, 21,
    29, 37, 10, 18, 26, 34, 15, 23, 31, 39,
    11, 19, 27, 35
};

int lk_16tab[] =
{
    14, 9,  13, 10, 22, 17, 21, 18, 30, 25,
    29, 26, 38, 33, 37, 34
};

/*** BeginHeader lk_kxinit */

int lk_kxinit(void);

/*** Endheader */

#ifndef KEYPAD_SIZE
#define KEYPAD_SIZE 24
#endif

/* START FUNCTION DESCRIPTION ********************************************
lk_kxinit                    <KDM.LIB>

SYNTAX: int lk_kxinit(void);

KEYWORDS: kdm, keypad, init

DESCRIPTION: Initializes variables, buffers and hardware driver associated
with servicing the KDM keypad.

RETURN VALUE:  None.
END DESCRIPTION **********************************************************/
nodebug int lk_kxinit(void)
{                            // initialize keyboard I/O

    // Init buffer to empty:
    lk_keytestr = lk_kxkey = lk_kxdead = lk_kxinptr = lk_kxoutptr = 0;
    lk_beepcount = 0;
    lk_timecnt = 0;
    lk_usetab = 0;
    if (KEYPAD_SIZE <= 24)
        lk_loadtab(NULL, 0);

    lk_keyw(0xffe0);         // write to key register
}

#funcchain _sys_781 _lk_781
#funcchain _sys_25msPostEI kx_keybdtest

/*** beginHeader lk_loadtab */

int lk_loadtab(int *tab, int tab_size);

/*** EndHeader */

#ifndef KEYPAD_SIZE
#define KEYPAD_SIZE 24
#endif

/* START FUNCTION DESCRIPTION ********************************************
lk_loadtab                   <KDM.LIB>

SYNTAX: int lk_loadtab(int *tab, int tab_size);

KEYWORDS: kdm, keypad

DESCRIPTION: Loads keypad numerical table values.  Used for rearranging the
keys of the keypad.  tab points to a integer array containing the new 
keypad arrangement. tab_size is the table size to change.  For example:  
new_table[] = {4,3,2,1,....} will rearrange the ordering of the first four 
keys.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug int lk_loadtab(int *tab, int tab_size)
{
    int k;

    if (tab == NULL)         // load table with default values
    {
        if (KEYPAD_SIZE == 24)
        {
            for (k = 0; k < 24; ++k)
                lk_tab[lk_24tab[k]] = k + 1;
        }
        else if (KEYPAD_SIZE == 16)
        {
            for (k = 0; k < 16; ++k)
                lk_tab[lk_16tab[k]] = k + 1;
        }
        else
        {
            for (k = 0; k < 40; ++k)
                lk_tab[k] = k + 1;
        }
        return;
    }

    if (tab_size > KEYPAD_SIZE)
        tab_size = KEYPAD_SIZE;
    if (tab_size > 40)
        tab_size = 40;

    if (KEYPAD_SIZE == 24)
    {
        for (k = 0; k < tab_size; ++k)
            lk_tab[lk_24tab[k]] = tab[k];
    }
    else
        if (KEYPAD_SIZE == 16)
        {
            for (k = 0; k < tab_size; ++k)
                lk_tab[lk_16tab[k]] = tab[k];
        }
        else
        {
            for (k = 0; k < tab_size; ++k)
                lk_tab[k + 1] = tab[k];
            lk_usetab = 1;
        }
}

/*** BeginHeader lk_settab */

int lk_settab(char flag);

/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
lk_settab                    <KDM.LIB>

SYNTAX: int lk_settab(char flag);

KEYWORDS: kdm, keypad

DESCRIPTION:  Sets to use the keypad translate table for keypad sizes 
greater than 24.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug int lk_settab(char flag)
{
    lk_usetab = flag;
}

/*** BeginHeader lk_keyw */

int lk_keyw(int flag);

/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
lk_keyw                      <KDM.LIB>

SYNTAX: int lk_keyw(int flag);

KEYWORDS: kdm, keypad

DESCRIPTION:  Writes to specified bits in the key register.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
#asm nodebug
lk_keyw::
   ld    a,i
   ex    af,af'
   di
   ld    a,(lk_keyshadow)
   ld    b,a
   ld    a,h   ;bits
   cpl
   and   b     ; shadow and not bits
   ld    b,a
   ld    a,h   ;bits
   and   l     ; new bits
   or    b     ; old bits
   ld    (lk_keyshadow),a
   ld    h,2
   ld    l,a   ;new value
   call  lk_wr ; write toregister
   ex    af,af'
   ret   po
   ei
   ret
#endasm


/*** BeginHeader lk_kxget */

int lk_kxget(char mode);

/*** EndHeader */

#ifndef KEYPAD_SIZE
#define KEYPAD_SIZE 24
#endif

/* START FUNCTION DESCRIPTION ********************************************
lk_kxget                     <KDM.LIB>

SYNTAX: int lk_kxget(char mode);

KEYWORDS: kdm, keypad

DESCRIPTION: Gets character from the KDM keypad. If mode = 0, removes
the character from the keypad buffer and return it. If mode !=0, returns
the character (if available) but do not remove from the keypad buffer.

RETURN VALUE: The keypad character pressed; else -1, if keypad buffer is 
empty.
END DESCRIPTION **********************************************************/
nodebug int lk_kxget(char mode)
{                            // get character from keyboard or return -1

    static char temp;
    static unsigned kk;

    if (lk_kxinptr == lk_kxoutptr)
        return -1;           // if buffer empty, return

    temp = lk_kxbuf[lk_kxoutptr];
    if (!mode)
        lk_kxoutptr = ++lk_kxoutptr & 0xf; // step circular buffer ptr

    if (KEYPAD_SIZE <= 24 || lk_usetab)
        temp = lk_tab[temp]; // 24 pos keypad
    return temp;
}

/*** BeginHeader lk_setbeep */

int lk_setbeep(int delay);

/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
lk_setbeep                   <KDM.LIB>

SYNTAX: int lk_setbeep(int count);

KEYWORDS: kdm, beep

DESCRIPTION: Setup the variables that is used for the KDM beeper.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug useix int lk_setbeep(int delay)
{
#asm nodebug xmemok
   ld    l,(ix+delay)
   ld    h,(ix+delay+1)
   ld    (lk_beepcount),hl    ; a shared with interrupt variable
#endasm
}


/*** BeginHeader lk_led */

int lk_led(int mode);

/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
lk_led                       <KDM.LIB>

SYNTAX: int lk_led(int mode);

KEYWORDS: kdm, LED

DESCRIPTION: Turns on/off LEDS on the KDM without conflicting with the
keypad driver.  Mode = 0, turns off the LEDS. Mode =1, turns on the yellow
LED. Mode = 2, turns on the green LED. Mode = 3, turns on both LEDS.

RETURN VALUE: The mode that was passed.
END DESCRIPTION **********************************************************/
nodebug int lk_led(int mode)
{
    int led_mask;

    if (mode < 0 || mode > 3)
        return -1;
    led_mask = 0x6000 | (mode << 5);// changing bits 4 and 5
    led_mask ^= 0x60;        // lights are on when signal low
    lk_keyw(led_mask);       // change the bits
    return mode;
}

/*** BeginHeader lk_tdelay */

int lk_tdelay(int delay);

/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
lk_tdelay                    <KDM.LIB>

SYNTAX: int lk_tdelay(int delay);

KEYWORDS: kdm, timer, delay

DESCRIPTION: Convenient delay mechanism that is tied to Timer 1 periodic
interrupt.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/

nodebug int lk_tdelay(int msec)
{
    lk_timecnt = 3 * (msec / 4);
    while (lk_timecnt);    // wait for interrupt routine to count it down
}

/*** beginHeader _lk_781 */

void _lk_781();

/*** EndHeader */

/*************************************************************\
*   Routine to service timer 1 interrupt and drive beeper, keypad
*   If RUNKERNEL is defined, then the real time kernel is also called.
\**************************************************************/
/* START FUNCTION DESCRIPTION ********************************************
lk_int_timer1                <KDM.LIB>

SYNTAX: int lk_int_timer1(void);

KEYWORDS: kdm, ISR, timer

DESCRIPTION: Service routine for timer 1 interrupt. Drives the beeper and
the keypad. Also drives the Real Time Kernel if RUNKERNEL is defined.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/

#asm nodebug root
_lk_781::
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; START OF KDM STUFF
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ld    hl,(lk_timecnt)
   ld    a,l
   or    h
   jr    z,nlk_timecnt
   dec   hl
   ld    (lk_timecnt),hl
nlk_timecnt:
   ld    hl,(lk_beepcount)
   ld    a,l
   or    h
   jr    z,timer2a
   dec   hl
   ld    (lk_beepcount),hl
; least of beep count is sent to beeper
   rr    l
   ccf                     ; so beeper won't rattle when disabled
   rr    l
   ld    h,80h             ; beeper only
   call  lk_keyw
timer2a:
   ret

#endasm

/*** BeginHeader kx_keybdtest */

void kx_keybdtest();

/*** EndHeader */

#asm

kx_keybdtest::
   ld    hl,1f1fh          ; lower all 5 rows
   call  lk_keyw
   ld    hl,2
   call  lk_rd
   ld    a,l               ;result
   cp    0ffh
   jr    z,kbtest1aa       ; quick test for no codes
   ld    hl,1f10h          ; output 5 columns
   ld    b,5               ;counter
kbtest1:
   push  hl
   push  bc
   call  lk_keyw
   ld    hl,2
   call  lk_rd
   ld    a,l               ; save result in a
   pop   bc
   pop   hl
   cp    0ffh              ; if any low, key depressed
   jr    nz,kbtest2
   rr    l                 ; shift to next
   djnz  kbtest1           ; loop 5 times
; come here if  no key depressed
kbtest1aa:
   ld    hl,1f00h          ; remove drive from outputs
   call  lk_keyw
   ld    a,(lk_kxkey)
   or    a
   ret   z                 ; if lk_kxkey ==0 and code==0 noactivity
kbtest1a:                  ; here to process counting dead time
   ld    a,(lk_kxdead)
   or    a
   jr    nz,kbtest1b
   xor   a
   ld    (lk_kxkey),a      ; done process on key
   ret
kbtest1b:
   dec   a
   ld    (lk_kxdead),a     ; step dead time count
   ret
; here a code was detected on keyboard, L is bit drive , A is bits received
kbtest2:
   ld    h,a               ; H has 1 low of 8 code, L has 1 high of 5 code
   push  hl
   ld    hl,1f00h
   call  lk_keyw           ; raise all drives
   pop   hl
   call  kbcvt             ;convert to 6 bit code in a
   ld    hl,lk_kxkey
   cp    (hl)              ; is this code a key holding?
   ret   z                 ; if so return
   push  af
   ld    a,(hl)
   or    a                 ; is kxcode==0?
   jr    z,kbtest4         ; new key
   pop   af
   jr    kbtest1a          ; go count out dead time
kbtest4:
   pop   af
   ld    (hl),a            ; save new key value
   call  kxput             ; put key in output circular buffer
   ld    a,3
   ld    (lk_kxdead),a     ; set dead time count
   ret
; place next keystroke into output buffer
kxput:
   push  af                ; save keycode
   ld    a,(lk_kxinptr)
   ld    hl,lk_kxoutptr
   inc   a
   and   0fh
   cp    (hl)              ; inptr+1 == outptr??
   jr    z,kxovfl          ; buffer full
   ld    h,a               ; new buffer
   ld    a,(lk_kxinptr)
   ld    l,a
   ld    a,h               ;new buf
   ld    (lk_kxinptr),a    ; save updated buf ptr
   ld    h,0
   ld    bc,lk_kxbuf
   add   hl,bc             ; address in buffer
   pop   af                ;keycode
   ld    (hl),a            ;save it
   ret
kxovfl:
	pop   af
   ld    hl,500
   ld    (lk_beepcount),hl ; make a long beep
   ret

; convert raw codes in hl to 6 bit code in a
kbtbl:   db 5,0,4,1,6,2,7,3   ; adjusting table
kbcvt:
   ld    b,8
   ld    a,h                  ; 1 of 8 low code
kbcvt1:
   rrca
   jr    nc,kbcvt2
   djnz  kbcvt1
kbcvt2:
   dec   b
   ld    e,b                  ; save 3 bits
   ld    d,0
   push  hl
   ld    hl,kbtbl
   add   hl,de
   ld    a,(hl)
   pop   hl
   ld    e,a                  ;adjusted
   ld    b,5
   ld    a,l
kbcvt3:
   rrca
   jr    c,kbcvt4
   djnz  kbcvt3
kbcvt4:
   dec   b
   xor   a                    ;clear carry
   ld    a,b
   rlca
   rlca
   rlca
   and   038h
   add   a,e
   inc   a                    ; avoid zero code
   ret

#endasm

/*** BeginHeader lg_init_keypad */
int lg_init_keypad(void);

/*** EndHeader  */

#ifndef LK_LINES
#define LK_LINES 8       // for graphics display
#endif

/* START FUNCTION DESCRIPTION ********************************************
lg_init_keypad               <KDM.LIB>

SYNTAX: int lg_init_keypad(void);

KEYWORDS: kdm, lcd, keypad, init

DESCRIPTION: Initializes timer1, KDM keypad driver and the Graphics LCD.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug int lg_init_keypad(void)
{
    int k;

    if (iff())
    {
        k = 1;
        DI();
    }
    else k = 0;

    lk_kxinit();             // initialize the keyboard input queue
    lg_init();               // initialize graphics lcd

	sysPRT1_781();
    
#ifdef RUNKERNEL             // if real time kernel included
   init_kernel();
#endif

    if (k)
        EI();
}

/*** BeginHeader lk_init_keypad */
int lk_init_keypad(void);

/*** EndHeader  */

#ifndef LK_LINES
#define LK_LINES 4
/* #define LK_LINES 8 */   /* for graphics display */

#endif

/* START FUNCTION DESCRIPTION ********************************************
lk_init_keypad               <KDM.LIB>

SYNTAX: int lk_init_keypad(void);

KEYWORDS: kdm, lcd, init

DESCRIPTION:  Initializes timer1, keypad driver and the LCD.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug int lk_init_keypad(void)
{
    auto int k;

    if (iff())
    {
        k = 1;
        DI();
    }
    else 
        k = 0;

    lk_kxinit();             // initialize the keyboard input queue
    if (LK_LINES < 8)
        lk_init();           // initialize the lcd display unit
    else
        lg_init();           // initialize graphics lcd

    sysPRT1_781();
    
#ifdef RUNKERNEL             // if real time kernel included
   init_kernel();
#endif

    if (k)
        EI();
}

/*** BeginHeader lk_wr, lk_rd */

void lk_wr(int x);

/*** EndHeader  */


/* START FUNCTION DESCRIPTION ********************************************
lk_wr                        <KDM.LIB>

SYNTAX: void lk_wr(int x);

KEYWORDS: kdm, lcd

DESCRIPTION: Writes low byte of x to LCD register in the high byte of x.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/

/* START FUNCTION DESCRIPTION ********************************************
lk_rd                        <KDM.LIB>

SYNTAX: int lk_rd(int addr);

KEYWORDS:  kdm, lcd, read

DESCRIPTION: Reads data from the LCD read register addr.

RETURN VALUE: Data from LCD read register addr.
END DESCRIPTION **********************************************************/
#asm nodebug
lk_wr::
   ld    bc,LCDWR+1
   ld    a,i                  ; get interrupt status
   ex    af,af'
   di                         ; disable interrupts
   out   (c),h                ; output the register designation
   dec   bc
   out   (c),l                ; output the data value
   ex    af,af'
   ret   po                   ; if interrupts were off
   ei
   ret

lk_rd::
   ld    bc,LCDWR+1
   ld    a,i
   ex    af,af'               ; save interrupt status
   di                         ; disable interrupts
   out   (c),l                ; output the register
   ld  bc,LCDRD
   in    l,(c)
   ld    h,0
   ex    af,af'
   ret   po
   ei
   ret

#endasm

/*** BeginHeader lk_init, lk_ctrl, lk_wait, lk_printf, lk_pos, lk_char */

int lk_init(void);            // initialize display  unit
int lk_putc(char x);          // send 1 character to LCD, process escape seq
int lk_printf(char *fmt, ...);// printf to LCD, process escape seq
int lk_pos(int line, int col);// position cursor to line, column

/* escape sequences
   ESC p n mm - position cursor to line n and column mm
          example:  lk_printf("\x1bp234"); line 2, column 34
                    lk_printf("\x1bp105"); line 1, column 5
                    lines are numbered 0, 1, 2, 3. Columns 0,1,..39.
   esc 1 - Turn on cursor
   esc 0 - Turn off cursor
   esc c - Erase from at cursor postion to end of line
   esc b - Enable blinking cursor mode.
   esc n - Disable blinking cursor mode.
   esc e - erase display and home cursor

*/

/*** EndHeader  */

#ifndef LK_LINES             // number of lines on display
#define LK_LINES 4           // default
#endif

#ifndef LK_COLS              // number of columns per line on display
#define LK_COLS 40           // default
#endif

#ifndef LK_BLINK
#define LK_BLINK 2           // set to 1 for blinking cursor
#endif

/*
 Write/read to/from display interface board
 Upper byte of 16 bit integer is register, lower byte data.
 On read, returns value in hl lower byte.

   registers:
      0 - LCD1 - first lcd unit control register
      4 - LCD1 - first lcd unit data register
      1 - LCD2 - second lcd unit control register
      5 - LCD2 - second lcd unit data register
      2 - KEYR - key (bits 0-4), buzzer (7) and LD1 - LD5 (4-5) register
      3 - USR  - LED6 register
*/

char lk_state, lk_blink, lk_line, lk_col; // current line and col position


/* START FUNCTION DESCRIPTION ********************************************
lk_init                      <KDM.LIB>

SYNTAX: int lk_init(void);

KEYWORDS: kdm, lcd, init

DESCRIPTION: Initializes LCD on the KDM.  Initializes software variables
associated with usage of the LCD.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug lk_init(void)
{
    static unsigned int k;

    lk_wr(0x38);
    lk_wr(0x138);

    for (k = 0; k < 400; k++) 
        ;                    // 4 ms delay

                             // function set 4 times per Sieko
    for (k = 0; k < 3; k++)
    {
        lk_wr(0x38);
        lk_wr(0x138);
        del100();
    }

    lk_cmd(0x006);           // entry mode set
    lk_cmd(0x00c + LK_BLINK);// display on, blinking cursor
    lk_cmd(0x001);           // clear display memory

    if (LK_LINES * LK_COLS > 80)
    {                        // if second display unit
        lk_cmd(0x106);       // entry mode
        lk_cmd(0x10c);       // cursor off on second unit
        lk_cmd(0x101);       // clear display memory
    }

    lk_state = lk_line = lk_col = 0;
    lk_blink = LK_BLINK;
}

/* START FUNCTION DESCRIPTION ********************************************
del100                       <KDM.LIB>

SYNTAX: int del100(void);

KEYWORDS: delay

DESCRIPTION: Software delay loop for the LCD module.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
int del100(void)
{
    static int k;
    
    for (k = 0; k < 8; k++)
        ;
}

/* START FUNCTION DESCRIPTION ********************************************
lk_cmd                       <KDM.LIB>

SYNTAX: int lk_cmd(int cmd);

KEYWORDS: kdm, lcd

DESCRIPTION: Sends command in the lower byte of cmd to the LCD register
specified by the upper byte of cmd.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug lk_cmd(int cmd)
{
    while (lk_rd(cmd >> 8) & 0x80) 
        ;                    // wait for busy flag
    lk_wr(cmd);
}



/* START FUNCTION DESCRIPTION ********************************************
lk_wait                      <KDM.LIB>

SYNTAX: int lk_wait(void);

KEYWORDS: kdm, lcd

DESCRIPTION: Waits for appropriate LCD unit to clear its busy flag.

RETURN VALUE: 0 or 1 depending on the LCD controller.
END DESCRIPTION **********************************************************/
nodebug lk_wait(void)
{
    static int k;

                             // 0 or 1 depending on controller
    k = LK_LINES * LK_COLS > 80 && lk_line > 1;

    while (lk_rd(k) & 0x80)
        ;
    return k;
}


/* START FUNCTION DESCRIPTION ********************************************
lk_char                      <KDM.LIB>

SYNTAX: int lk_char(char x);

KEYWORDS: kdm, lcd

DESCRIPTION: Sends one character to data register of the appropriate LCD.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug lk_char(char x)
{
    static union
    {
        char kk[2];
        int k;
    } u;

    u.kk[1] = lk_wait() + 4; // point to correct data register
    u.kk[0] = x;
    lk_wr(u.k);
}

/* START FUNCTION DESCRIPTION ********************************************
lk_ctrl                      <KDM.LIB>

SYNTAX: int lk_ctrl(char x);

KEYWORDS: kdm, lcd

DESCRIPTION: Sends one character to control register of the appropriate
LCD unit.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug lk_ctrl(char x)
{
    static union
    {
        char kk[2];
        int k;
    } u;

    u.kk[1] = lk_wait();     // point to correct data register
    u.kk[0] = x;
    lk_wr(u.k);
}

/* START FUNCTION DESCRIPTION ********************************************
lk_putc                      <KDM.LIB>

SYNTAX: int lk_putc(char x);

KEYWORDS: kdm, lcd

DESCRIPTION: Low level driver (printf analogue) for the LCD. Sends a 
character to the LCD and updates sofware variables for storing the LCD 
screen status.  

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug indirect lk_putc(char x)
{
    static int k, nl, nc;

    switch (lk_state)
    {
        case 0:             // output a normal character
            if (x == 27)
            {                // escape received
                lk_state = 1;
            }
            else if (x == 0xa)
                lk_nl();
            else
            {
                lk_char(x);
                lk_col++;
                if (lk_col >= LK_COLS)
                    lk_nl();
            }
            return;

        case 1:               // character after escape
            if (x == 'p')
            {
                lk_state = 2;
                return;
            }
            else if (x == '1')
                lk_ctrl(0xc + lk_blink);// enable cursor
            else if (x == '0')
                lk_ctrl(0xc); // disable cursor
            else if (x == 'n')
            {                 // blink off
                lk_blink = 2;
                lk_ctrl(0xc + lk_blink);
            }
            else if (x == 'b')// blink on
            {
                lk_blink = 1;
                lk_ctrl(0xc + lk_blink);
            }
            else if (x == 'c')// erase to eol
            {
                for (k = lk_col; k < LK_COLS; k++)
                    lk_char(' ');
                lk_pos(lk_line, lk_col);
            }
            else if (x == 'e')
            {
                lk_pos(0, 0);
                lk_ctrl(1);
                if (LK_COLS * LK_LINES > 80)
                    lk_cmd(0x101); // erase second unit
            }
            lk_state = 0;
            return;
        case 2:               // get row number
            nl = x - '0';
            lk_state = 3;
            return;
        case 3:             // get tens digit for column
            nc = 10 * (x - '0');
            lk_state = 4;
            return;
        case 4:             // and position cursor
            lk_pos(nl, nc + (x - '0'));
            lk_state = 0;
            return;
    }
}

/* START FUNCTION DESCRIPTION ********************************************
lk_nl                        <KDM.LIB>

SYNTAX: int lk_nl(void);

KEYWORDS: kdm lcd

DESCRIPTION: Generates a "newline" on the LCD screen.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug lk_nl(void)
{
    if (++lk_line >= LK_LINES)
        lk_line = LK_LINES - 1;
    lk_col = 0;
    lk_pos(lk_line, 0);
}

/* START FUNCTION DESCRIPTION ********************************************
lk_pos                       <KDM.LIB>

SYNTAX: int lk_pos(int line, int col);

KEYWORDS: kdm, lcd

DESCRIPTION: Positions LCD cursor to line and col location.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug lk_pos(int line, int col)
{
    static int k, j, n;

    n = (line & 1) * 0x40 + col;
    lk_line = line;
    lk_col = col;

    if (LK_COLS * LK_LINES > 80)
    {                        // 4 x 40 display
        k = lk_wait();

        if (j = ((k == 0) ^ (line < 2)))
            lk_ctrl(0xc);    // disable current cursor
        lk_ctrl(0x80 + n);   // position

        if (j)
            lk_ctrl(0xc + lk_blink); // reenable cursor
    }
    else
    {
        if (line < 2)
            lk_ctrl(0x80 + n);
        else
            lk_ctrl(0x94 + n); // 4 x 20 display
    }
}

/* START FUNCTION DESCRIPTION ********************************************
lk_printf                    <KDM.LIB>

SYNTAX: int lk_printf(char *fmt, ...);

KEYWORDS: kdm, lcd

DESCRIPTION: Printf analogue for the LCD. The following Escape sequences
are available:
   ESC p n mm - position cursor to line n and column mm
          example:  lk_printf("\x1bp234"); line 2, column 34
                    lk_printf("\x1bp105"); line 1, column 5
   lines are numbered 0, 1, 2, 3. Columns 0,1,..39.
   esc 1 - Turn on cursor
   esc 0 - Turn off cursor
   esc c - Erase from at cursor postion to end of line
   esc b - Enable blinking cursor mode.
   esc n - Disable blinking cursor mode.
   esc e - erase display and home cursor

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug lk_printf(char *fmt, ...)
{
    int lk_putc();

    doprnt(lk_putc, fmt, (char *) ((char *) &fmt + sizeof (fmt)),NULL);
}

/*** BeginHeader lg_cgram */

lg_cgram(char *p);           // set character generator ram

/*** EndHeader lg_cgram */

/* START FUNCTION DESCRIPTION ********************************************
lg_cgram                     <KDM.LIB>

SYNTAX: lg_cgram(char *p);

KEYWORDS: graphics, kdm, lcd

DESCRIPTION: Special character generator for the graphics LCD. "*p" (first byte)
is the number of bytes to store (up to 1024 for 128 characters). 
User defined RAM chars are assigned to character codes 128-255,
the first 8 bytes at "p" go to char code 128, the 2nd 8 bytes to char code
129, etc.

Note that the output functions lg_putc and lg_char convert from
ASCII by subtracting 32 from their char arguments. Therefore another means
must be used to output RAM chars > 223 since the user must add 32 to the
argument to these functions to output RAM chars. That is, ASCII char codes
160 - 255 correspond to LCD char codes 128-223. To ouput char codes
224 - 255, lg_xchar may be used with the non-ASCII argument, but
lg_printf will not handle these codes correctly.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug lg_cgram(char *p)
{
	int j,k,n;
 	unsigned address,code;
   n = *p++;              // get count
	code = 0;
	for (k = 0; k < n/8; k++){ //each char. uses 8 bytes

		// user character RAM starts at 1c00h
		// the address of each character contains
		// the charater code
		address = 0x1c00 | (code<<3);
   	lg_wr(address&0x00ff);       // write low byte of address 
  		lg_wr((address>>8)&0xff);    // write high byte of address 

		// pointer set command sets write pointer to address
      lg_wr(0x0420 | 4);       

		for (j = 1; j <= 8; j++){
	      lg_wr(*p++);	  // write byte to CG RAM 
			lg_wr(0x04c0);   //   after pointer increment
		}
		code++;
	}
}


/*** BeginHeader lk_cgram */

lk_cgram(char *p);           // set character generator ram

/*** EndHeader lk_cgram */

/* START FUNCTION DESCRIPTION ********************************************
lk_cgram                     <KDM.LIB>

SYNTAX: lk_cgram(char *p);

KEYWORDS: kdm, lcd

DESCRIPTION: Special character generator for the LCD. *p (first byte)
is the number of bytes to store (up to 64 for 8 characters). The lower 5 
bits of each byte make one row of the character from left to right and top 
to bottom. The 8th row of each is in the cursor position.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug lk_cgram(char *p)
{
    static int k, n;

    n = *p++;                // get count
    for (k = 0; k < n; k++)
    {
        lk_cmd(0x040 + k);
        while (lk_rd(0) & 0x80)
            ;
        lk_wr(0x400 + *p);

        if (LK_LINES * LK_COLS > 80)
        {
            lk_cmd(0x140 + k);
            while (lk_rd(1) & 0x80);
            lk_wr(0x500 + *p);
        }
        p++;
    }
    lk_pos(0, 0);            // reenable mode 0
}

/*** BeginHeader lk_stdcg,lg_stdcg  */

int lk_stdcg(void);
int lg_stdcg(void);

/*** EndHeader */

/* table of custom characters to be loaded in character generating
   ram.
*/

char lk_stdchars[] =
{
    64,
    0x04, 0x02, 0x1f, 0x02, 0x04, 0x00, 0x00, 0x00, // 08 right arrow
    0x00, 0x00, 0x00, 0x04, 0x04, 0x15, 0x0e, 0x04, // 09 down arrow
    0x00, 0x00, 0x00, 0x04, 0x0e, 0x15, 0x04, 0x04, // 02 up arrow
    0x04, 0x08, 0x1f, 0x08, 0x04, 0x00, 0x00, 0x00, // 0b left arrow
    0x08, 0x0c, 0x0e, 0x0f, 0x0e, 0x0c, 0x08, 0x00, // 0c arrow cursor
    0x02, 0x07, 0x02, 0x0a, 0x0a, 0x08, 0x1c, 0x08, // 0d up down symbol
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, // 0e vertical line
    0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00  // 0f horizontal line

};

/* START FUNCTION DESCRIPTION ********************************************
lk_stdcg                     <KDM.LIB>

SYNTAX: int lk_stdcg(void);

KEYWORDS:  KDM, LCD SPECIAL CHARACTERS.

DESCRIPTION: Loads a table of special characters, lk_stdchars[],to the LCD.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug lk_stdcg(void)
{
    lk_cgram(lk_stdchars);
}

/* START FUNCTION DESCRIPTION ********************************************
lg_stdcg                     <KDM.LIB>

SYNTAX: int lg_stdcg(void);

KEYWORDS:  KDM, LCD SPECIAL CHARACTERS.

DESCRIPTION: Loads a table of special characters, lk_stdchars[],to the LCD.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug lg_stdcg(void)
{
    lg_cgram(lk_stdchars);
}

/*** BeginHeader lk_run_menu */

struct lk_limits
{
    float lower;
    float upper;
    float step;
};

struct lk_menu
{
    int   mtype;             // menu type code
    char  *msg;              // pointer to format string
    union lk_ptx             // pointer to data variable involved
    {
        char      *logical;
        unsigned  *daytimer; // 16 bit time of day
        float     *fl;
        struct tm *dat;
        struct lk_menu *nextmenu;
    } valptr;

    struct lk_limits *lim;   // limits on variable

    int (*func)();           // pointer to function to call
};

int lk_run_menu(char *call_menu, struct lk_menu *menu, int index);

/*** EndHeader */


/* START FUNCTION DESCRIPTION ********************************************
lk_run_menu                  <KDM.LIB>

SYNTAX: int lk_run_menu(char *call_menu, struct lk_menu *menu, int index);

KEYWORDS: kdm

DESCRIPTION: Menuing scheme for the KDM unit. The following mtype codes
in the menu structures are available:
   codes:
   0- end of menu
   1- view floating
   2- view floating and adjust in limits
   3- view floating and enter new value on enter
   4- like 2 but call specified function passing pointer after each step
   5- like 3 but call specified function passing pointer to new value

   8- view logical
   9- view logical and adjust true/false
   10 - like 9 but call specified function passing pointer to variable

   16 - view date/time
   17 - view/ modify date/ time
   18 - view/ modify date / time and call routine

   20 - view time (16-bit)
   21 - view/ modify time (16-bit)
   22 - view/ modify time (16-bit) and then call routine

   32 - call a new menu, msg is top line name for new menu, valptr is the
        pointer to the new menu structure, the index is always passed as 0

   40 - call a function, msg is displayed, ptr and limit is ignored

The string call_menu is initially printed when the menu is entered. The
pointer menu points to the lk_menu structure. The index is the starting
point in the menu, often zero. The run_menu function returns the last
value of the index.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug int lk_run_menu(char *call_menu, struct lk_menu * menu, int index)
{
    int    i, j, k;
    char   refresh;
    shared float *fptr;        // floating pointer
    struct lk_limits * limptr; // limits array ptr
    char   *lptr;              // logical pointer
    shared unsigned *uptr;     // unsigned pointer
    struct lk_menu *kptr;
    struct tm *dat;
    char   cused;              // set if character used
    int    code;
    int    ref_count;          // refresh counter

    ref_count = 0;
    k         = index;         // index in menu array
    kptr      = menu + k;
    refresh   = 1;             // refresh display
    lk_printf(call_menu);
    uptr = (void *)(dat = (struct tm *)(lptr = (void *)(fptr = 
                   (void *)(kptr->valptr.fl))) );  // pointer to value
    while (1)
    {
    	hitwd();
        uptr = (unsigned *)(dat = (struct tm *) (lptr = (char *)(fptr = 
                       (float *)kptr->valptr.fl))); // pointer to value

        j = lk_kxget(1);    // next char
        cused = 0;
        if (refresh)
        {
            if ((i & 16) == 0 && (i != 32) )
                lk_printf(call_menu); // except date/ time update top line

            if ((i = kptr->mtype) < 8)
                lk_printf(kptr->msg, *fptr);
            else if (i < 16)
                lk_viewl(kptr->msg, *lptr);
            else if (i < 20)
                lk_showdate(kptr->msg, dat);
            else if (i < 23)
                lk_showtime(kptr->msg, *uptr);
            else if ((i & 32) != 0)
                lk_printf(kptr->msg);

            refresh = 0;
        }
        if (j == -1)
        {                          // if no character found
            lk_tdelay(10);         // delay 10 milliseconds

            if (++ref_count > 100) // refresh every second
            {
                ref_count = 0;
                refresh = 1;
            }
            continue;
        }                    // waiting for character
stepper:
        if (j == '*')
        {
            if (k != 0)
                --k;
            else
                while ((menu + k + 1) ->mtype)
                    k++;     // wrap to end of menu

            lk_secho();
            refresh = 1;
            cused = 1;
        }
        else if (j == '.')
        {
            if ((menu + k + 1) ->mtype)
                k++;
            else 
                k = 0;

            lk_secho();
            refresh = 1;
            cused   = 1;
        }
        else if (j >= '3' && j <= '9') // escape
            return k;

        kptr = menu + k;
        
        // set up various pointers
        uptr = (unsigned *)(dat = (struct tm *)(lptr = (char *)(fptr = 
                       (float *)(kptr->valptr.fl))) ); // pointer to value

        limptr = kptr->lim;  // pointer to limits structure
        switch (code = kptr->mtype)
        {
            case 1:          // view floating variable
                refresh = 1;
                break;

            case 2:          // step  floating variable
            case 4:
                if (j == '+')
                {
                    if (*fptr < limptr->upper)
                    {
                        *fptr = *fptr + limptr->step;
                        lk_secho();
                        
                        if (code == 4) // call specified function
                            (*kptr->func)(fptr);
                    }
                    else 
                        lk_lecho();

                    cused = 1;
                    refresh = 1;
                }
                else if (j == '#')
                {
                    if (*fptr > limptr->lower)
                    {
                        *fptr = *fptr - limptr->step;
                        lk_secho();

                        if (code == 4)
                            (*kptr->func)(fptr); // call specified function
                    }
                    else 
                        lk_lecho();

                    refresh = 1;
                    cused = 1;
                }
                break;
            case 3:         // get keyboard input
            case 5:
                if (j == '#' || j == '+' || j == 10)
                {
                    lk_secho();
                    lk_printf("\x1bp000\x1bc");
                    lk_printf(kptr->msg + 5, *fptr);
                    *fptr = (float)lk_getknum();

                    if (code == 5)
                        (*kptr->func)(fptr); // call specified function
                    lk_printf(call_menu);
                    refresh = 1;
                }
                break;
            case 8:         // view logical variable
                refresh = 1;
                break;
            case 9:         // adjust logical variable
            case 10:
                if (j == '#' || j == '+')
                {
                    *lptr = ! *lptr;
                    lk_secho();
                    cused = 1;

                    if (code == 10)
                        (*kptr->func)(lptr); // call specified function
                }
                refresh = 1;
                break;
            case 16:        // date time view
                break;
            case 17:        // modify date time
            case 18:
                if (j == 10 || j == '#' || j == '+')
                {
                    lk_secho();
                    lk_setdate(kptr->msg, dat);
                    if (code == 18)
                        (*kptr->func)(dat); // call specified function
                }
                refresh = 1;
                break;
            case 20:
                break;       // time view
            case 21:
            case 22:
                if (j == 10 || j == '#' || j == '+')
                {
                    lk_secho();
                    *uptr = lk_settime(kptr->msg, *uptr);
                    if (code == 22)
                        (*kptr->func)(uptr); // call specified function
                }
                refresh = 1;
                break;
            case 32:
                if (j == 10)
                {
                    lk_secho();
                    lk_run_menu(kptr->msg, kptr->valptr.nextmenu, 0);
                    lk_printf(call_menu);
                }
                refresh = 1;
                break;
            case 40:
                if (j == 10)
                {
                    lk_secho();
                    (*kptr->func)();
                }
                refresh = 1;
                break;
        }
        if (! cused)
            lk_lecho();      // dump bad characters
    }                        // end of while
}


/*** BeginHeader lk_setdate, lk_chkdat, lk_showdate*/

int lk_setdate(char *msg, struct tm *dat); // get new date from user
int lk_chkdat(struct tm *dat);
int lk_showdate(char *msg, struct tm *tmm);

/*** EndHeader */


/* START FUNCTION DESCRIPTION ********************************************
lk_setdate                   <KDM.LIB>

SYNTAX: lk_setdate(char *msg, struct tm *dat);

KEYWORDS:  kdm, lcd, date

DESCRIPTION:  Sets date data and prints to the LCD. Also prints msg to the
LCD.  Used by lk_run_menu().

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug lk_setdate(char *msg, struct tm * dat)
{
    int  i, j, iold;
    int  step;
    long int ll;
    char *p;

    static char pos[] =
    {
        0, 1, 3, 4, 7, 8, 10, 14, 15
    };                           // cursor positions
    static char ofsets[] =
    {
        2, 2, 1, 1, 3, 3, 4, 5, 5
    };                           // offsets in structure
    static char amt[] =
    {
        10, 1, 10, 1, 10, 1, 1, 10, 1
    };                           // amt to add to each

    iold = 8;
    i    = 0;
    p    = (char *)dat;
    dat->tm_sec = 0;

    while (1)
    {
        j = lk_kxget(0);     // get next character from keyboard
        if (iold != i)
        {
            iold = i;
            lk_pos(1, pos[i]);
        }                    // position cursor

        if (j == -1)
            continue;

        if (j == '*')
        {
            if (i > 0)
                --i;
            lk_secho();
        }                    // step left
        else if (j == '.')
        {
            if (i < 8)
                ++i;
            lk_secho();
        }                    // step right

                             // up down count
        p = (char *) dat;
        p = p + ofsets[i];   // pointer to char to change
        step = amt[i];

        if (j == '#')
        {                    // step down
            step = -step;
        }

        if (j == '#' || j == '+')
        {
            *p = *p + step;
            if (!lk_chkdat(dat) )
            {
                *p = *p - step;
                lk_lecho();
            }
            else
            {
                lk_secho();
                lk_showdate(msg, dat);
                lk_pos(1, pos[i]);
            }
        }
        if (j == 10)
        {
            lk_secho();
            ll = mktime(dat); // set day of week
            mktm(dat, ll);
            return;
        }
    }
}



/* START FUNCTION DESCRIPTION ********************************************
lk_chkdat                    <KDM.LIB>

SYNTAX: int lk_chkdat(struct tm *dat);

KEYWORDS: kdm, lcd, date

DESCRIPTION:  Checks validity of date data.  May change day of the month.

RETURN VALUE: 0, if date data is okay; else 1, for invalid date data.
END DESCRIPTION **********************************************************/
nodebug int lk_chkdat(struct tm * dat)
{
    int  ii;
    static char mmon[13] =
    {
        0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
    };

    if (!(dat->tm_sec  < 60 && dat->tm_min  < 60 && dat->tm_hour < 24 && 
          dat->tm_year < 180 && dat->tm_mon  > 0  && dat->tm_mon  < 13 && 
          dat->tm_wday < 7  && dat->tm_mday > 0) )
        return 0;

    if (dat->tm_mday > mmon[dat->tm_mon])
        dat->tm_mday = mmon[dat->tm_mon];

    if (dat->tm_mon == 2 && dat->tm_mday == 29) // leap day
    {
        if ((dat->tm_year & 3) != 0)
            dat->tm_mday = 28;
    }
    return 1;
}


/* START FUNCTION DESCRIPTION ********************************************
lk_showdate                  <KDM.LIB>

SYNTAX: lk_showdate(char *msg, struct tm *tmm);

KEYWORDS:  kdm, lcd, date

DESCRIPTION: Displays date data and msg to the LCD.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug lk_showdate(char *msg, struct tm *tmm)
{
    static int yr;
    static char *month[] =
    {
        "void", "Jan", "Feb", "Mar", "Apr", "May",
        "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
    };

    yr = tmm->tm_year;
    if (yr >= 100)
        yr = yr - 100;

    lk_printf(msg);

    lk_printf("\x1bp100\x1bc%2d:%02d  %2d-%s-%02d", 
    tmm->tm_hour, tmm->tm_min, tmm->tm_mday, month[tmm->tm_mon], yr);
}

/*** BeginHeader lk_settime, lk_showtime */

unsigned lk_settime(char *msg, unsigned time);
int      lk_showtime(char *msg, unsigned time);

/*** Endheader */

/* modifies time and returns new value */

/* show a time of day expressed in 2 second units as an unsigned */


/* START FUNCTION DESCRIPTION ********************************************
lk_settime                   <KDM.LIB>

SYNTAX: unsigned lk_settime(char *msg, unsigned time);

KEYWORDS: kdm, lcd, time

DESCRIPTION: Sets time and prints to the LCD.  Also prints msg to LCD.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug unsigned lk_settime(char *msg, unsigned time)
{
    int          i, j, iold;
    unsigned int step;

    static char pos[] =
    {
        0, 1, 3, 4, 6, 7
    };                       // cursor positions
    static unsigned amt[] =
    {
        18000, 1800, 300, 30, 5, 1
    };                       // step in structure

    iold = 6;
    i    = 0;                // i is cursor postion 0-5

    while (1)
    {
        j = lk_kxget(0);     // get next character from keyboard

        if (iold != i)
        {
            iold = i;
            lk_pos(1, pos[i]);
        }                    // position cursor

        if (j == -1)
            continue;

        if (j == '*')
        {
            if (i > 0)
                --i;
            lk_secho();
        }                    // step left
        else if (j == '.')
        {
            if (i < 6)
                ++i;
            lk_secho();
        }                    // step right

                             // up down count
        step = amt[i];
        if (j == '#')
        {                    // step down
            step = -step;
        }

        if (j == '#' || j == '+')
        {
            time = time + step;
            if (time > 43199)
            {
                time = time - step;
                lk_lecho();
            }
            else
            {
                lk_secho();
                lk_showtime(msg, time);
                lk_pos(1, pos[i]);
            }
        }

        if (j == 10)
        {
            lk_secho();
            return time;
        }
    }
}


/* START FUNCTION DESCRIPTION ********************************************
lk_showtime                  <KDM.LIB>

SYNTAX: int lk_showtime(char *msg, unsigned time);

KEYWORDS: kdm, lcd, time

DESCRIPTION: Displays msg and time data on the LCD.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug int lk_showtime(char *msg, unsigned time)
{
    lk_printf(msg);
    lk_printf(msg);
    lk_printf("\x1bp100\x1bc%02d:%02d:%02d", 
    st_hour(time), st_min(time), st_sec(time) );
}

/*** BeginHeader st_hour,st_min,st_sec,ad_st */

int      st_hour(unsigned j);
int      st_min(unsigned j);
int      st_sec(unsigned j);
unsigned mk_st(int hour, int min, int sec);
unsigned ad_st(unsigned t1, unsigned t2); // add 2 times together

/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
st_hour                      <KDM.LIB>

SYNTAX: int st_hour(unsigned j);

KEYWORDS: kdm, time

DESCRIPTION:  Hour parser used by lk_run_menu(). 
seconds.

RETURN VALUE: (int)(j/1800)
END DESCRIPTION **********************************************************/
int st_hour(unsigned j)
{
    return j / 1800;
}

/* START FUNCTION DESCRIPTION ********************************************
st_min                       <KDM.LIB>

SYNTAX: int st_min(unsigned j);

KEYWORDS: kdm, time

DESCRIPTION:  Minutes parser used by lk_run_menu().

RETURN VALUE:  (j % 1800) / 30.
END DESCRIPTION **********************************************************/
int st_min(unsigned j)
{
    return (j % 1800) / 30;
}

/* START FUNCTION DESCRIPTION ********************************************
st_sec                       <KDM.LIB>

SYNTAX: int st_sec(unsigned j);

KEYWORDS: kdm, time

DESCRIPTION: Seconds parser used by lk_run_menu().

RETURN VALUE:  2 * (j % 30).
END DESCRIPTION **********************************************************/
int st_sec(unsigned j)
{
    return 2 * (j % 30);
}

/* START FUNCTION DESCRIPTION ********************************************
mk_st                        <KDM.LIB>

SYNTAX: unsigned mk_st(int hour, int min, int sec);

KEYWORDS: kdm, time

DESCRIPTION: Time data builder used by lk_run_menu().

RETURN VALUE: hour*1800+min*30+sec*2.
END DESCRIPTION **********************************************************/
unsigned mk_st(int hour, int min, int sec)
{
    return hour * 1800 + min * 30 + sec * 2;
}


/* START FUNCTION DESCRIPTION ********************************************
ad_st                        <KDM.LIB>

SYNTAX: unsigned ad_st(unsigned t1, unsigned t2);

KEYWORDS: kdm, time

DESCRIPTION: Time data adder used by lk_run_menu().

RETURN VALUE: Adjusted time data of the two times added together.
END DESCRIPTION **********************************************************/
unsigned ad_st(unsigned t1, unsigned t2)
{
    unsigned t3;

    t3 = t1 + t2;
    if (t3 > 43199) 
        t3 = t3 - 43200U;
    return t3;
}

/*** BeginHeader lk_secho, lk_lecho */

int lk_secho(void);
int lk_lecho(void);

/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
lk_secho                     <KDM.LIB>

SYNTAX: int lk_secho(void);

KEYWORDS: kdm, keypad

DESCRIPTION: Pulls character from key buffer and generates a short beep.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug int lk_secho(void)
{
    lk_kxget(0);
    lk_setbeep(60);
}

/* START FUNCTION DESCRIPTION ********************************************
lk_lecho                     <KDM.LIB>

SYNTAX: int lk_lecho(void);

KEYWORDS: kdm, keypad

DESCRIPTION: Pulls character from the keypad buffer and do a long beep.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug int lk_lecho(void)
{
    lk_kxget(0);
    lk_setbeep(160);
}                            // error echo


/*** BeginHeader lk_viewl */

int lk_viewl(char *fmt, char var);

/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
lk_viewl                     <KDM.LIB>

SYNTAX: int lk_viewl(char *fmt, char var);

KEYWORDS: kdm

DESCRIPTION: Views a logical variable.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug int lk_viewl(char *fmt, char var)
{
    static char *p;

    lk_printf("\x1bp100\x1bc");// clear line and position cursor
    p = fmt;

    if (var)
    {
        while (*p != '/')
            ++p;
        ++p;
    }                        // step to true

    while (*p != '/' && *p != 0)
        lk_putc(*p++);       // print false or true msg
}


/*** BeginHeader lk_getknum */

float lk_getknum(void);

/*** EndHeader */



/* START FUNCTION DESCRIPTION ********************************************
lk_getknum                   <KDM.LIB>

SYNTAX: float lk_getknum(void);

KEYWORDS: kdm, keypad

DESCRIPTION: Gets a floating point number from the keypad.

RETURN VALUE: Floating point number entered through the keypad.
END DESCRIPTION **********************************************************/
nodebug float lk_getknum(void)
{
    int  ch, k, p;           // ch-char, k-index, p-period detected
    char st[16];

    lk_printf("\x1bp100\x1bc?? "); // clear line 2 of display, print ??

    p = k = 0;               // index, no period yet
    while (1)
    {
        switch (ch = lk_kxget(0))
        {                    // get a character from keyboard
            case -1:
                continue;    // no character ready
            case '-':
                if (k == 0)
                    goto out;
                else
                    goto error; // - as first only
            case '.':
                if (p++== 0)
                    goto out;
                else
                    goto error; // one . only
            case '*':
                goto back;      // the DEL key
            case 10:
                if (k == 0)
                    goto error;

                st[k] = 0;
                goto done;   // enter key
            default:
                if (ch < '0' || ch > '9')
                    goto error;// digit ??

                out: st[k++] = ch;
                lk_putc(ch);
                lk_setbeep(60);// good digit
                continue;

                error: lk_setbeep(120);
                continue;    // bad something typed, ignore

                             // backspace on delete key
                back: lk_setbeep(60);
                if (k)
                    --k;     // don't backspace past first column

                if (st[k] == '.')
                    p = 0;   // remove period if backover it

                lk_pos(1, k + 3);// position-space-position
                lk_putc(0x20);
                lk_pos(1, k + 3);
        }
    }
done:
    return atof(st);         // convert to floating
}

/*** BeginHeader lg_init,lg_char,lg_putc,lg_pos,lg_printf,Set_Display_Mode,
                 Clear_GrTxt_Screen */

int lg_init(void);            // initialize display unit
int lg_char(char x);
int lg_putc(char x);          // send 1 character to LCD, process escape seq
int lg_printf(char *fmt, ...);// printf to LCD, process escape seq
int lg_pos(int line, int col);// position cursor to line, column
int Set_Display_Mode(int mode);
void Clear_GrTxt_Screen(void);

/* escape sequences
   ESC p n mm - position cursor to line n and column mm
          example:  lg_printf("\x1bp234"); line 2, column 34
                    lg_printf("\x1bp105"); line 1, column 5
   lines are numbered 0, 1, 2, 3. Columns 0,1,..39.
   esc 1 - Turn on cursor
   esc 0 - Turn off cursor
   esc c - Erase from at cursor postion to end of line
   esc b - Enable blinking cursor mode.
   esc n - Disable blinking cursor mode.
   esc e - erase display and home cursor

*/

int lg_row_bytes;            // number of bytes per row

#ifndef LG_HDOTS          // number of
#define LG_HDOTS  240     // horizantal pixels
#endif

#ifndef LG_VDOTS             // number of
#define LG_VDOTS  64      // vertical pixels
#endif

#ifndef GRTXT_BASE_ADDRESS
#define GRTXT_BASE_ADDRESS 0x1000
#define PIXELS_PER_BYTE    6
#define GR_BASE_ADDRESS    0
#define TOTAL_GR_BYTES     LG_VDOTS * LG_HDOTS / PIXELS_PER_BYTE
#endif

#ifndef WR_OFF
#define WR_OFF 0
#define WR_ON  1
#define WR_XOR 2
#endif

/*** EndHeader  */

#ifndef CURSOR_POINTER     
#define CURSOR_POINTER     1
#define ADDRESS_POINTER    4
#endif

/* Graphics LCD Auto Mode parameters
------------------------------------ */

#ifndef AUTO_WRITE
#define AUTO_WRITE         0
#define AUTO_READ          1
#define AUTO_RESET         2
#endif

/* Graphics LCD Mode parameters
----------------------------------- */

#ifndef DISPLAY_GRAPHICS
#define DISPLAY_GRAPHICS   8
#define DISPLAY_TEXT       4
#define CURSOR_ON          2
#define CURSOR_BLINK       1
#endif

#ifndef LK_LINES             // number of lines on display
#define LK_LINES 8           // default
#endif

#ifndef LK_COLS              // number of columns per line on display
#define LK_COLS 40           // default
#endif

/*
 Write (read) to/from display interface board
   Upper byte of 16 bit integer is register, lower byte data.
   On read returns value in hl lower byte

   registers:
     0 - LCD1 - first lcd unit control register
     4 - LCD1 - first lcd unit data register
     1 - LCD2 - second lcd unit control register
     5 - LCD2 - second lcd unit data register
     2 - KEYR - key (bits 0-4), buzzer (7) and LD1 - LD5 (4-5) register
     3 - USR  - LED6 register
*/

char lg_state, lg_line, lg_col;// current line and column position
char lg_mode;                  // current display mode

#ifndef LK_LINES
#define LK_LINES 8             // for graphics display
#endif

/* START FUNCTION DESCRIPTION ********************************************
lg_init                      <KDM.LIB>

SYNTAX: int lg_init(void);

KEYWORDS: kdm, lcd, init

DESCRIPTION: Initializes the LCD and its associated software variables.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug int lg_init(void)
{
    lg_state = lg_line = lg_col = 0;
    lg_row_bytes = LG_HDOTS / PIXELS_PER_BYTE;
    Graph_Init();
    Clear_Gr_Screen();
    Clear_GrTxt_Screen();
    Set_Overlap_Mode(0);
    Set_Display_Mode(0x0F);  // everything on
    Define_Cursor(2);
    lg_pos(0, 0);
}

/* START FUNCTION DESCRIPTION ********************************************
lg_char                      <KDM.LIB>

SYNTAX: int lg_char(char x);

KEYWORDS: kdm, lcd

DESCRIPTION: Writes an ASCII character to the LCD.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug int lg_char(char x)
{
	if(x >= ' '){
    lg_wr(x - ' ');        // Char = " "
    lg_wr(0x04C0);         // Send Command:Data write w/pointer-increment
	}
}

/* START FUNCTION DESCRIPTION ********************************************
lg_xchar                      <KDM.LIB>

SYNTAX: int lg_xchar(char x);

KEYWORDS: kdm, lcd

DESCRIPTION: Writes a character to the LCD. "x" is an LCD (non-ASCII)
character code.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug int lg_xchar(char x)
{
    lg_wr(x&0x00ff);        
    lg_wr(0x04C0);         // Send Command:Data write w/pointer-increment
}

/* START FUNCTION DESCRIPTION ********************************************
lg_putc                      <KDM.LIB>

SYNTAX: int lg_putc(char x);

KEYWORDS: kdm, lcd

DESCRIPTION: Low level driver (printf analogue) for the for LCD.  Puts a 
character on the LCD and updates sofware variables that store the LCD 
screen status.  

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug indirect int lg_putc(char x)
{
    static int k, nl, nc;

    switch (lg_state)
    {

        case 0:              // output a normal character
            if (x == 27)
            {                // escape received
                lg_state = 1;
            }
            else if (x == 0xa)
                lg_nl();
            else 
            {
                lg_char(x);
                lg_col++;
                if (lg_col >= LK_COLS)
                    lg_nl();
                if (lg_mode & 2)
                    Set_Pointer(((lg_line << 8) | lg_col), CURSOR_POINTER);
            }
            return;

        case 1:             // character after escape
            if (x == 'p')
            {
                lg_state = 2;
                return;
            }
            else if (x == '1')
            {
                Set_Display_Mode(lg_mode | CURSOR_ON);// enable cursor
                lg_pos(lg_line, lg_col);
            }
            else if (x == '0')
                Set_Display_Mode(lg_mode & ~CURSOR_ON);// disable cursor
            else if (x == 'n')
            {                // blink off
                Set_Display_Mode(lg_mode & ~CURSOR_BLINK);
            }
            else if (x == 'b')// blink on
            {
                Set_Display_Mode(lg_mode | CURSOR_BLINK);
            }
            else if (x == 'c')// erase to eol
            {
                for (k = lg_col; k < LK_COLS; k++)
                    lg_char(' ');
                lg_pos(lg_line, lg_col);
            }
            else if (x == 'e')
            {
                Clear_GrTxt_Screen();
            }
            lg_state = 0;
            return;
        case 2:             // get row number
            nl = x - '0';
            lg_state = 3;
            return;
        case 3:             // get tens digit for column
            nc = 10 * (x - '0');
            lg_state = 4;
            return;
        case 4:             // and position cursor
            lg_pos(nl, nc + (x - '0'));
            lg_state = 0;
            return;
    }
}

/* START FUNCTION DESCRIPTION ********************************************
lg_nl                        <KDM.LIB>

SYNTAX: int lg_nl(void);

KEYWORDS: kdm, lcd

DESCRIPTION: Generates a "newline" on LCD Graphics screen.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug int lg_nl(void)
{
    if (++lg_line >= LK_LINES)
        lg_line = LK_LINES - 1;
    lg_col = 0;
    lg_pos(lg_line, 0);
}


/* START FUNCTION DESCRIPTION ********************************************
lg_pos                       <KDM.LIB>

SYNTAX: int lg_pos(int line, int col);

KEYWORDS: kdm, lcd

DESCRIPTION: Positions cursor on the LCD Graphics screen.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug int lg_pos(int line, int col)
{
    lg_line = line;
    lg_col  = col;

    Set_Pointer(Text_Addr(lg_col, lg_line), ADDRESS_POINTER);
    if (lg_mode & CURSOR_ON)
        Set_Pointer(((lg_line << 8) | lg_col), CURSOR_POINTER);
}


/* START FUNCTION DESCRIPTION ********************************************
lg_printf                    <KDM.LIB>

SYNTAX: int lg_printf(char *fmt, ...);

KEYWORDS: kdm, lcd, graphics

DESCRIPTION: Printf analogue for the LCD Graphics. The following Escape
sequences are available:
   ESC p n mm - position cursor to line n and column mm
          example:  lk_printf("\x1bp234"); line 2, column 34
                    lk_printf("\x1bp105"); line 1, column 5
   lines are numbered 0, 1, 2, 3. Columns 0,1,..39.
   esc 1 - Turn on cursor
   esc 0 - Turn off cursor
   esc c - Erase from at cursor postion to end of line
   esc b - Enable blinking cursor mode.
   esc n - Disable blinking cursor mode.
   esc e - erase display and home cursor

RETURN VALUE:
END DESCRIPTION **********************************************************/
nodebug int lg_printf(char *fmt, ...)
{
    doprnt(lg_putc, fmt, (char *) ((char *) &fmt + sizeof (fmt)),NULL);
}


/* START FUNCTION DESCRIPTION ********************************************
Set_Display_Mode             <KDM.LIB>

SYNTAX: int Set_Display_Mode(int mode);

KEYWORDS: kdm, lcd, graphics

DESCRIPTION: Sets the display mode of the LCD graphics. Mode is
DISPLAY_TEXT (4) or DISPLAY_GRAPHICS (8).

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug int Set_Display_Mode(int mode)
{
    lg_wr(0x0490 | mode);
    lg_mode = mode;
}


/* START FUNCTION DESCRIPTION ********************************************
Clear_GrTxt_Screen           <KDM.LIB>

SYNTAX: void Clear_GrTxt_Screen(void);

KEYWORDS: kdm, lcd

DESCRIPTION:  Clears the LCD Graphics TEXT screen.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug void Clear_GrTxt_Screen(void)
{
    int i, cur_mode;

    cur_mode = lg_mode;
    
    Set_Display_Mode(DISPLAY_TEXT);  // Select Text display Only

    // Set Text Address pointer to 0x1000
    Set_Pointer(GRTXT_BASE_ADDRESS, ADDRESS_POINTER);

    for (i = 0; i < (LK_LINES * LK_COLS); i++)
        lg_char(' ');        // Clear each Text Cell
    Set_Display_Mode(cur_mode);
    lg_pos(0, 0);
}

/*** BeginHeader Stall, sta01, sta03, lg_wr, lg_wr03, lg_rd */

int  Stall(int tix);
void lg_wr(int x);

/*** EndHeader  */


/* START FUNCTION DESCRIPTION ********************************************
Stall                        <KDM.LIB>

SYNTAX: int Stall(int tix);

KEYWORDS: delay

DESCRIPTION: Software delay loop. Counts down tix*10.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug int Stall(int tix)
{
    static int k;

    for (; tix; --tix)
        for (k = 0; k < 10; ++k);
}

/* START FUNCTION DESCRIPTION ********************************************
sta01                        <KDM.LIB>

SYNTAX: void sta01(void);

KEYWORDS: kdm, lcd, graphics

DESCRIPTION: Writes 4 to the LCD Write Register and waits for a 3 on the 
LCD Read Register.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/

/* START FUNCTION DESCRIPTION ********************************************
sta03                        <KDM.LIB>

SYNTAX: void sta03(void);

KEYWORDS: kdm, lcd, graphics

DESCRIPTION: Writes 4 to the LCD Write Register and waits for a 0x08 on 
the LCD Read Register.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/

/* START FUNCTION DESCRIPTION ********************************************
lg_wr                        <KDM.LIB>

SYNTAX: void lg_wr(int x);

KEYWORDS:  kdm, lcd, graphics

DESCRIPTION: Writes data to LCD Register.  Reg value is in the high byte 
and data value is in the low byte of x.  Uses sta01() to wait for clear 
to write.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/

/* START FUNCTION DESCRIPTION ********************************************
lg_wr03                      <KDM.LIB>

SYNTAX: void lg_wr03(int x);

KEYWORDS: kdm, lcd, graphics

DESCRIPTION: Writes data to LCD Register.  Reg value is in the high byte 
and data value is in the low byte of x.  Uses sta03() to wait for clear 
to write.

RETURN VALUE:
None
END DESCRIPTION **********************************************************/

/* START FUNCTION DESCRIPTION ********************************************
lg_rd                        <KDM.LIB>

SYNTAX: int lg_rd(void);

KEYWORDS: kdm, lcd, graphics, read

DESCRIPTION: Waits for clear and reads the LCD Read Register.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
#asm nodebug
sta01::
   ld    bc, LCDWR+1
   ld    a, 4
   out   (c), a
   ld  bc,LCDRD
Loop01:
	dec   d				; allow max tries in d
	jp    nz,Loop02	;  then exit BPM 10-04-95
	ret
Loop02:
   in    a, (c)
   and   3
   dec   a
   dec   a
   dec   a
   jr    nz, Loop01
   ret

sta03::
   ld    bc, LCDWR+1
   ld    a, 4
   out   (c), a
   ld  bc,LCDRD
Loop03:
   in    a, (c)
   and   0x08
   jr    z, Loop03
   ret

lg_wr::
	ld    d,255						; max # tries
   ld    a,i                  ; get interrupt status
   ex    af,af'
   di                         ; disable interrupts
   call  sta01
   ld    bc,LCDWR+1
   out   (c),h                ; output the register designation
   dec   bc
   out   (c),l                ; output the data value
   ex    af,af'
   ret   po                   ; if interrupts were off
   ei
   ret

lg_wr03::
	ld    d,255						; max # tries
   ld    a,i                  ; get interrupt status
   ex    af,af'
   di                         ; disable interrupts
   call  sta03
   ld    bc,LCDWR+1
   out   (c),h                ; output the register designation
   dec   bc
   out   (c),l                ; output the data value
   ex    af,af'
   ret   po                   ; if interrupts were off
   ei
   ret

lg_rd::
	ld    d,255						; max # tries
   ld    a,i                  ; get interrupt status
   ex    af,af'
   di                         ; disable interrupts
   call  sta01
   ld    bc,LCDWR+1
   out   (c),l                ; output the register designation
   ld  bc,LCDRD
   in    l,(c)                ; read the data
   ld    h, 0
   ex    af,af'
   ret   po                   ; if interrupts were off
   ei
   ret

#endasm


/*** BeginHeader grp_home_area, text_home_area, Graph_Init */

int grp_home_area(char gal, char gah, char ghl, char ghh);
int text_home_area(char tal, char tah, char thl, char thh);

/*** EndHeader  */


/* START FUNCTION DESCRIPTION ********************************************
grp_home_area                <KDM.LIB>

SYNTAX: int grp_home_area(char gal, char gah, char ghl, char ghh);

KEYWORDS: kdm, lcd, graphics

DESCRIPTION: Sets the graphics area by defining the home (ghl,ghh)
and the area (gal,gah).

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug int grp_home_area(char gal, char gah, char ghl, char ghh)
{                            // control word set 4 00xx
    int k;

    if (iff())
    {
        k = 1;
        DI();
    }
    else 
        k = 0;

    lg_wr(ghl);              // home address lowbyte
    lg_wr(ghh);              // home address highbyte=00
    lg_wr(0x0442);           // graphic home address set GH

    lg_wr(gal);              // GA=0x27
    lg_wr(gah);              // GA=0x0027
    lg_wr(0x0443);           // GA graphic Area set

    if (k)
        EI();
}


/* START FUNCTION DESCRIPTION ********************************************
text_home_area               <KDM.LIB>

SYNTAX: int text_home_area(char tal, char tah, char thl, char thh);

KEYWORDS: kdm, lcd, graphics

DESCRIPTION: Sets the text area by defining the home (thl,thh) and the
area (tal,tah).

RETURN VALUE:  None.
END DESCRIPTION **********************************************************/
nodebug int text_home_area(char tal, char tah, char thl, char thh)
{                            // control word set 4 00xx
    int k;

    if (iff())
    {
        k = 1;
        DI();
    }
    else 
        k = 0;

    lg_wr(thl);              // home address lowbyte=00
    lg_wr(thh);              // home address highbyte=10
    lg_wr(0x0440);           // text home address set TH

    lg_wr(tal);              // TA=0x27
    lg_wr(tah);              // TA=0x0027
    lg_wr(0x0441);           // text Text Area set

    if (k)
        EI();
}

/* START FUNCTION DESCRIPTION ********************************************
Graph_Init                   <KDM.LIB>

SYNTAX: int Graph_Init(void);

KEYWORDS: kdm, lcd, graphics

DESCRIPTION: Initializes the LCD Graphics Text and Graphics Areas.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug int Graph_Init(void)
{
    char gal, gah, ghl, ghh, thl, thh, tal, tah;
    int  k;

    outport(DCNTL, 0x30);
    lg_wr(0);                // hardware reset

    gal = (char)( (LG_HDOTS / PIXELS_PER_BYTE) & 0XFF);
    gah = (char)( (LG_HDOTS / PIXELS_PER_BYTE) >> 8);

    ghl = (char)(GR_BASE_ADDRESS & 0x00);
    ghh = (char)(GR_BASE_ADDRESS >> 8);

    thl = (char)(GRTXT_BASE_ADDRESS & 0xFF);
    thh = (char)(GRTXT_BASE_ADDRESS >> 8);

    tal = (char)(LK_COLS & 0xFF);
    tah = (char)(LK_COLS >> 8);

                             // mode set
    lg_wr(0x0480);           // Graphic "OR" CG ROM Text display

    grp_home_area(gal, gah, ghl, ghh);
    text_home_area(tal, tah, thl, thh);
}

/*** BeginHeader Set_Pointer, Text_Addr, Set_Auto_Mode,
                 Set_Overlap_Mode, Define_Cursor */

void Set_Pointer(int address, int ptr);
int Text_Addr(int col, int row);
void Set_Auto_Mode(int mode);
void Set_Overlap_Mode(int mode);
void Define_Cursor(int lines);

/*** EndHeader  */

/* START FUNCTION DESCRIPTION ********************************************
Set_Pointer                  <KDM.LIB>

SYNTAX: void Set_Pointer(int address, int ptr);

KEYWORDS: kdm, lcd, graphics

DESCRIPTION: Sets the appropriate pointer by using the "Pointer Set" 
command (pg. 25 of the Toshiba ST-LCD manual). address is the address to 
set the pointer to. ptr is the pointer to set: 1=cursor, 2=offset, 4=address.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug void Set_Pointer(int address, int ptr)
{
    lg_wr(address & 0x00FF); // write low byte of address
    lg_wr(address >> 8);     // write high byte of address
    lg_wr(0x0420 | ptr);
}

/* START FUNCTION DESCRIPTION ********************************************
Text_Addr                    <KDM.LIB>

SYNTAX: int Text_Addr(int col, int row);

KEYWORDS: kdm, lcd, graphics

DESCRIPTION: Computes location of text, based on the row and col data.

RETURN VALUE: GRTXT_BASE_ADDRESS+row*LK_COLS+col.
END DESCRIPTION **********************************************************/
nodebug int Text_Addr(int col, int row)
{
    return (GRTXT_BASE_ADDRESS + row * LK_COLS + col);
}


/* START FUNCTION DESCRIPTION ********************************************
Set_Auto_Mode                <KDM.LIB>

SYNTAX: void Set_Auto_Mode(int mode);

KEYWORDS: kdm, lcd, graphics

DESCRIPTION: Sets the LCD graphics into auto mode.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug void Set_Auto_Mode(int mode)
{
    lg_wr(0x04b0 | mode);
}

/* START FUNCTION DESCRIPTION ********************************************
Set_Overlap_Mode             <KDM.LIB>

SYNTAX: void Set_Overlap_Mode(int mode);

KEYWORDS: kdm, lcd, graphics

DESCRIPTION: Sets the LCD Graphics to Overlap Mode.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug void Set_Overlap_Mode(int mode)
{
    lg_wr(0x0480 | mode);
}

/* START FUNCTION DESCRIPTION ********************************************
Define_Cursor                <KDM.LIB>

SYNTAX: void Define_Cursor(int lines);

KEYWORDS: kdm, lcd, graphics

DESCRIPTION: Defines the cursor for the LCD Graphics.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug void Define_Cursor(int lines)
{
    --lines;
    lg_wr(0x04a0 | lines);
}

/*** BeginHeader Set_Pixel */

void Set_Pixel(int col, int row, int wr_mode);


/*** EndHeader  */

// 2-15-96, Redefine to allow usage in this function. It is
// 2-15-96, ignored if previously defined.

/* Graphics LCD Auto Mode parameters
------------------------------------ */

#ifndef AUTO_WRITE
#define AUTO_WRITE         0
#define AUTO_READ          1
#define AUTO_RESET         2
#endif

/* START FUNCTION DESCRIPTION ********************************************
Set_Pixel                    <KDM.LIB>

SYNTAX: void Set_Pixel(int col, int row, int wr_mode);

KEYWORDS: kdm, lcd, graphics

DESCRIPTION:  Sets an LCD pixel to coord's (col, row). wr_mode = 0 to 
clear, wr_mode=1 to set and wr_mode=2 to XOR.  (0,0) is lower left corner. 
col ranges from 0-239; row ranges from 0-63.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/

nodebug void Set_Pixel(int col, int row, int wr_mode)
{
    static int bytenum, row_byte, k;
    static char mask, col_byte;

#asm xmemok
   call  calc_col_byte
   ld    a, l
   ld    (col_byte), a
   ld    a, h
   ld    (mask), a
#endasm
    if (mask >= PIXELS_PER_BYTE)
    {
        mask -= PIXELS_PER_BYTE;
        ++col_byte;
    }

    Set_Auto_Mode(AUTO_RESET);

    row_byte = LG_VDOTS - row - 1; // Adjust for axis in lower left corner
    bytenum = GR_BASE_ADDRESS + row_byte * lg_row_bytes + col_byte;
    mask = (abs(mask - PIXELS_PER_BYTE)) - 1;

    if (iff())
    {
        k = 1;
        DI();
    }
    else 
        k = 0;

    lg_wr(bytenum & 0x00ff); // write low byte
    lg_wr(bytenum >> 8);     // write high byte
    lg_wr(0x0424);

    bytenum = wr_mode;
    if (bytenum == WR_XOR)
    {
#asm xmemok
        ld    hl, 0x04C5     ; read PEEK'd value command
        call  lg_wr
        ld    hl, 0          ; get the value
        call  lg_rd
        ld    a, l           ; rotate right accum fastest
        ld    hl, (mask)     ; get bit number to look at
        inc   l
LoopS:
        rrca                 ; rotate bit to carry
        dec   l
        jr    nz, LoopS
        jr    c, SkipS       ; if carry set clear bit
        inc   l
SkipS:
        ld    h, 0
        ld    (bytenum), hl
#endasm
    }

    if (bytenum)
        SET(&mask, 3);

                             // for data check !
    lg_wr03(0x04F0 | mask);

    if (k)
        EI();
}

#asm nodebug
calc_col_byte::
    ld    a, l
    ld    bc, PIXELS_PER_BYTE
    ld    de, 0xF8
    ld    hl, 0
    tst   e
    jr    z, skip
loop:
    sub   c
    inc   l
    tst   e
    jr    nz, loop
skip:
    ld    h, a
    ret
#endasm

/*** BeginHeader Clear_Gr_Screen */

void Clear_Gr_Screen(void);

/*** EndHeader */


/* START FUNCTION DESCRIPTION ********************************************
Clear_Gr_Screen              <KDM.LIB>

SYNTAX: void Clear_Gr_Screen(void);

KEYWORDS: kdm, lcd, graphics

DESCRIPTION: Erases the Graphic Palette by writing 0's to all addresses
in the LCD Graphics RAM.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug void Clear_Gr_Screen(void)
{
    int i;

    Set_Display_Mode(DISPLAY_GRAPHICS);
    Set_Pointer(GR_BASE_ADDRESS, ADDRESS_POINTER);
    Set_Auto_Mode(AUTO_WRITE);

    for (i = 0; i < TOTAL_GR_BYTES; i++)
        lg_wr03(0);

    Set_Auto_Mode(AUTO_RESET);
}

/*** BeginHeader Map_Bit_Pattern */

void Map_Bit_Pattern(int *config, char *bitarray, int wr_mode);

/*** EndHeader */


/* START FUNCTION DESCRIPTION ********************************************
Map_Bit_Pattern              <KDM.LIB>

SYNTAX: void Map_Bit_Pattern(int *config, char *bitarray, int wr_mode);

KEYWORDS: kdm, lcd, graphics

DESCRIPTION: Maps a bit pattern to the LCD Graphics Area. config points to
an array of 4 integer data defining the upper left corner (x,y) to start
the pattern and the width and height of the figure in dots. bitarray points
to a character data array that has '1' or '*' in each location to set a dot
in. Data appears in sequential order, starting at the top left corner
progressing left to right and top to bottom. wr_mode = 0 to clear;
wr_mode = 1 to set and wr_mode = 2 to XOR.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug void Map_Bit_Pattern(int *config, char *bitarray, int wr_mode)
{
    int a, b, ox, oy, width, height;

    ox = *config++;
    oy = *config++;
    width  = *config++;
    height = *config++;

    for (b = oy + height - 1; b > oy - 1; b--)
        for (a = ox; a < ox + width; a++)
        {
            if (*bitarray == 1 || *bitarray == '*')
                Set_Pixel(a, b, wr_mode);
            bitarray++;
        }
}

/*** BeginHeader Draw_Line, Draw_Poly, Draw_Axis */

void Draw_Line(int stx, int sty, int enx, int eny, int wr_mode);
void Draw_Poly(int numpoints, int *points, int wr_mode);
void Draw_Axis(int ox, int oy, int ex, int ey, int ticks_x, int ticks_y, 
    int wr_mode);

/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
Draw_Line                    <KDM.LIB>

SYNTAX: void Draw_Line(int stx, int sty, int enx, int eny, int wr_mode);

KEYWORDS: kdm, lcd, graphics

DESCRIPTION: Draws a line from starting point (stx,sty) to end point
(enx,eny). wr_mode=0 to clear, wr_mode=1 to set and wr_mode=2 to XOR.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug void Draw_Line(int stx, int sty, int enx, int eny, int wr_mode)
{
    int   xchg, ychg, xpt, ypt, calcpts, i, l;
    float slope;

    Set_Pixel(stx, sty, wr_mode);
    Set_Pixel(enx, eny, wr_mode);
    xchg = enx - stx;
    ychg = eny - sty;

    if (xchg != 0)
    {
        if (ychg != 0)
        {
            calcpts = (abs(xchg) > abs(ychg)) ? abs(xchg): abs(ychg);
            slope = ychg / xchg;

            for (i = 0; i < calcpts; i++)
            {
                xpt = (int)(stx + ( (float)i / (float)calcpts) * xchg + 0.5);
                ypt = (int)(sty + ( (float)i / (float)calcpts) * ychg + 0.5);
                Set_Pixel(xpt, ypt, wr_mode);
            }
        }
        else                 // Horizontal Line
        {
            if (enx > stx)
            {
                for (l = stx; l < stx + xchg; l++)
                    Set_Pixel(l, sty, wr_mode);
            }
            else
            {
                for (l = stx; l > stx + xchg; l--)
                    Set_Pixel(l, sty, wr_mode);
            }
        }
    }
    else                     // Vertical Line
    {
        if (eny > sty)
        {
            for (i = sty; i < sty + ychg; i++)
                Set_Pixel(stx, i, wr_mode);
        }
        else
        {
            for (i = sty; i > sty + ychg; i--)
                Set_Pixel(stx, i, wr_mode);
        }
    }
}


/* START FUNCTION DESCRIPTION ********************************************
Draw_Poly                    <KDM.LIB>

SYNTAX: void Draw_Poly(int numpoints, int *points, int wr_mode);

KEYWORDS: kdm, lcd, graphics

DESCRIPTION: Draws a polygon by connecting succesive points. numpoints is
the number of (x,y) coodinate pairs. point points to an integer array of
(x,y) coordinate pairs.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug void Draw_Poly(int numpoints, int *points, int wr_mode)
{
    int looper;

    for (looper = 0; looper < numpoints - 1; looper++)
    {
        Draw_Line(*points, *(points + 1), *(points + 2), *(points + 3), 
        wr_mode);

        points += 2;
    }
}

/* START FUNCTION DESCRIPTION ********************************************
Draw_Axis                    <KDM.LIB>

SYNTAX: void Draw_Axis(int ox, int oy, int ex, int ey, int ticks_x, 
            int ticks_y, int wr_mode);

KEYWORDS: kdm, lcd, graphics

DESCRIPTION: Draws an axis with (ox,oy) as the axis origin. (ex,ey) as the
highest coordinates of the axis. ticks_x is the number of x-axis ticks.
ticks_y is the number of y-axis ticks.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug void Draw_Axis(int ox, int oy, int ex, int ey,
            int ticks_x, int ticks_y, int wr_mode)
{
    int lenx, leny, xti, yti, a;

    Draw_Line(ox, oy, ox, ey, wr_mode);
    Draw_Line(ox, oy, ex, oy, wr_mode);

    lenx = ex - ox;
    leny = ey - oy;

    for (a = 1; a < ticks_x + 1; a++)
    {
        xti = (int)( (float)lenx / (float)ticks_x * (float)a + ox);
        Draw_Line(xti, oy + 1, xti, abs(oy - 1), wr_mode);
    }

    for (a = 1; a < ticks_y + 1; a++)
    {
        yti = (int)( (float)leny / (float)ticks_y * (float)a + oy);
        Draw_Line(ox + 1, yti, abs(ox - 1), yti, wr_mode);
    }
}

/*** BeginHeader Sin_Wave */

void Sin_Wave(int ox, int oy, int ex, int ey, int cycles, int wr_mode);

/*** EndHeader */


/* START FUNCTION DESCRIPTION ********************************************
Sin_Wave                     <KDM.LIB>

SYNTAX: void Sin_Wave(int ox, int oy, int ex, int ey, int cycles, 
            int wr_mode);

KEYWORDS: kdm, lcd, graphics, trig.

DESCRIPTION: Draws a sine wave with (ox,oy) as the sinwave origin. (ex,ey)
as the highest possible coordinate of the wave. Cycles is the number of
cycles to display.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug void Sin_Wave(int ox, int oy, int ex, int ey, int cycles, int wr_mode)
{
    float a, b, deg;
    int   lenx, leny;

    lenx = ex - ox + 1;
    leny = ey - oy + 1;

    for (b = 0; b < lenx; b++)
    {
        deg = b * cycles / lenx * 360.0;
        a = sin(deg * 2.0 * 3.1416 / 360.0)
        *(float)(leny / 2) + 0.5 + (float)(oy + leny / 2);
        Set_Pixel( (int)(ox + b), (int)a, wr_mode);
    }
}

/*** BeginHEader */

#endif

/*** EndHeader */
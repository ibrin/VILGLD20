// 1-26-96, Allow transmitter to overflow receiver beyond CTS not ready.
// 11-13-95, add mask for receive data; 0x7f for 7 bits, 0xff for 8 bits.
// 7-13-95, compute 80% and 20% of buffer with float multiply.
/* START LIBRARY DESCRIPTION *********************************************
S0232.LIB
    Copyright (c) 1994, Z-World.

DESCRIPTION: RS232 driver for KIO serial port #A (first port on KIO).
This is a "Little Giant only" library.

SUPPORT LIB'S: modem232.lib, rtk.lib
END DESCRIPTION **********************************************************/

/*** BeginHeader */
#if BOARD_TYPE!=LITTLE_GIANT
#error "Little Giant only."
#endif
/*** EndHeader */

/*** Beginheader Dinit_s0, Dwrite_s0, Dread_s0, Dkill_s0, Dwrite_s01ch,
                 Dread_s01ch,Dreset_s0tbuf, Dreset_s0rbuf, s0modemstat,
                 s0modemset, s0binaryset, s0binaryreset, Drestart_s0modem */

int  Dinit_s0(char *rbuf, char *tbuf, int rsize, int tsize,
             char mode, char baud, char ismodem, char isecho); 
int  Dwrite_s0(char *buf, int count);     // Initiate send
int  Dread_s0(char *buf, char terminate); // Initiate receive
void Dkill_s0(void);                      // Abort all
int  Dwrite_s01ch(char data);
int  Dread_s01ch(char *data);
void Dreset_s0tbuf(void);
void Dreset_s0rbuf(void);
void Ds0send_prompt(void);
void Drestart_s0modem(void);
int  Ds0modem_chk(char *buf);
int  s0modemstat(void);
int  s0modemset(void);
void s0binaryset(void);
void s0binaryreset(void);

/*** Endheader */

char *s0_write_buf;          // Static pointer to the transmit buffer
char *s0_read_buf;           // Static pointer to the receive buffer
shared int s0_rx_head;       // Head pointer for the receive buffer
shared int s0_rx_tail;       // Tail pointer for the receive buffer
shared int s0_tx_head;       // Head pointer for the transmit buffer
shared int s0_tx_tail;       // Tail pointer for the transmit buffer
int s0_rx_size;              // Static storage of receive buffer size
int s0_tx_size;              // Static storage of transmit buffer size

shared int s0_80rbuf;
shared int s0_20rbuf;
shared int s0_rbufcnt;
shared int s0_tbufcnt;
char s0_CRTS_ENB;
char s0_CTS_ON;
char s0_echo;
char s0Binary;               // = 1, serial receive is in binary mode
                             // = 0, serial receive is in text mode
char s0CmdOrData;            // 1 if modem is in command mode
char s0UseModem;             // 1 if using modem

char s0_wreg5;               // keep state of SIO registers
char s0_wreg1;
char s0_wreg3;
char s0_wreg4;

char s0_data_mask;            // 11-13-95, data mask     
                              // 11-13-95, 0x7f for 7 bits, 0xff for 8 bits


/* START FUNCTION DESCRIPTION ********************************************
s0binaryset                  <S0232.LIB>

SYNTAX: void s0binaryset(void);

DESCRIPTION: Sets serial communication mode to binary.  All receive 
data are stuffed directly into the receive buffer.  Use for binary mode 
data transfer.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug void s0binaryset(void)
{
    s0Binary = 1;
}

/* START FUNCTION DESCRIPTION ********************************************
s0binaryreset                <S0232.LIB>

SYNTAX: void s0binaryreset(void);

DESCRIPTION: Resets serial communication to ASCII mode.  Backspace 
character is tracked to adjust the receive buffer head index.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug void s0binaryreset(void)
{
    s0Binary = 0;
}

/* START FUNCTION DESCRIPTION ********************************************
s0modemstat                  <S0232.LIB>

SYNTAX: int s0modemstat(void);

DESCRIPTION: Returns modem status.

RETURN VALUE: 1, if modem is in command mode; 0, if modem in data 
mode (i.e. open to communication).
END DESCRIPTION **********************************************************/
nodebug int s0modemstat(void)
{
    return (s0CmdOrData);
}

/* START FUNCTION DESCRIPTION ********************************************
s0modemset                   <S0232.LIB>

SYNTAX: int s0modemset(void);

DESCRIPTION: Returns information about modem selection.

RETURN VALUE: 1, if modem option is selected; else 0.
END DESCRIPTION **********************************************************/
nodebug int s0modemset(void)
{
    return (s0UseModem);
}

/* START FUNCTION DESCRIPTION ********************************************
Ds0send_prompt               <S0232.LIB>

SYNTAX: void Ds0send_prompt(void);

DESCRIPTION: Sends 'CR' 'LINEFEED' '>' to SIO channel 0.  Does not 
check for available space in the transmit buffer.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug void Ds0send_prompt(void)
{
    static char prompt[4] =
            {
                ENTER, LINEFEED, '>', '\0'
            };
    
    Dwrite_s0(prompt, 3);
}

/* START FUNCTION DESCRIPTION ********************************************
Dinit_s0                     <S0232.LIB>

SYNTAX: int Dinit_s0(char *rbuf, char *tbuf, int rsize, int tsize, 
        char mode, char baud, char ismodem, char isecho);
DESCRIPTION: Initializes SIO port 1 for serial communication.  "rbuf" and
"tbuf" point to user defined receive and transmit character arrays, whose
respective sizes are "rsize" and "tsize."  "mode" is defined as follows:
bit0 = 0/1 for 1/2 stop bit(s);  bit1 = 1/0 for parity/no parity; bit2 =
0/1 for 7/8 data bits; bit3 = 0/1 for even/odd parity; bit4 = 0/1 for CTS, RTS
9600 baud).  "ismodem" is 1/0, if modem is/is not used.  "isecho" is 1/0, if
char's are/are not echoed.

RETURN VALUE: 1.
END DESCRIPTION **********************************************************/
nodebug int Dinit_s0(char *rbuf, char *tbuf, int rsize, int tsize,
             char mode, char baud, char ismodem, char isecho)
{
    static char  var;

    s0Binary = 0;
    s0UseModem = ismodem;
    s0_echo    = isecho;
    s0_read_buf  = rbuf;
    s0_write_buf = tbuf;
    Dreset_s0tbuf();
    Dreset_s0rbuf();
    s0_rx_size = rsize;
    s0_tx_size = tsize;
    outport(SIOCA, 0x18);    // Reset port A
    setctc(1, 2, siobaud(sysclock(), baud), 0); // Init CTC for baud rate

    s0_wreg1 = 0x40;
    outport(SIOCA, 0x11);    // Wr reg 1
    outport(SIOCA, 0x40);    // int all rec char's, parity error special

    s0_wreg3 = 0x40;         // 7 data bits
    s0_data_mask = 0x7f;     // 11-13-95, mask for 7 data bits
    if (BIT(&mode, 2)) 
    {    
      SET(&s0_wreg3, 7);      // Data bits receive
      s0_data_mask = 0xff;    // 11-13-95, mask for 8 data bits
    }

    s0_wreg5 = (s0_wreg5 & 0x80) | 2;      // RTS on, initially
    s0_wreg5 = s0_wreg5 | (s0_wreg3 >> 1); // data bits transmit

    s0_wreg4 = 0x44;         // One stop bit, clock X 16, no parity
    if (BIT(&mode, 0)) 
        SET(&s0_wreg4, 3);   // Stop bits

    if (BIT(&mode, 1))       // Parity selected
        SET(&s0_wreg4, 0);   // Enable parity

    /* NOTE: parity bit is not stripped from characters. 
       User code must mask off 8th bit.                 */

    if ( !(BIT(&mode, 3)))   // Bit 3, 0 => even, 1 => odd parity
        SET(&s0_wreg4, 1);

    if (mode & '\B00010000') // CTS  and RTS ON
    {
        s0_CRTS_ENB = 1;
        s0_80rbuf = rsize * 0.80 ;  // 7-13-95 (rsize * 80) / 100;
        s0_20rbuf = rsize * 0.20 ;  // 7-13-95 (rsize * 20) / 100;
    }
    else 
        s0_CRTS_ENB = 0;

    s0_CTS_ON = 1;


    outport(SIOCA, 0x13);
    outport(SIOCA, s0_wreg3); // Set the registers
    outport(SIOCA, 0x14);
    outport(SIOCA, s0_wreg4);
    outport(SIOCA, 0x15);
    outport(SIOCA, s0_wreg5);
    intoff(&var);             // Disable interrupts, if on
    outport(SIOCA, 0x5);      // Enable transmitter
    outport(SIOCA, s0_wreg5 = s0_wreg5 | 8);
    doint();                  // Give interrupts a chance
                              // Enable transmitter interrupts
    outport(SIOCA, 0x33);     // Reset error, register 3
    outport(SIOCA, s0_wreg3 = s0_wreg3 | 1); // Enable receiver
    doint();
    outport(SIOCA, 0x11);
    outport(SIOCA, s0_wreg1 = s0_wreg1 | 0x18); // Enable receiver ints
    inton(&var);

    if (s0UseModem)
        Drestart_s0modem();
    else 
        s0CmdOrData = 0;     // Serial port is just in data mode
    return 1;
}

/* START FUNCTION DESCRIPTION ********************************************
Dreset_s0rbuf                <S0232.LIB>

SYNTAX: void Dreset_s0rbuf(void);

DESCRIPTION: Resets SIO channel 0 receive buffer . Sets head and tail
indexes to zero.  Sets s0_rbufcnt to zero.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug void Dreset_s0rbuf(void)
{
    s0_rbufcnt = s0_rx_head = s0_rx_tail = 0;
}

/* START FUNCTION DESCRIPTION ********************************************
Dreset_s0tbuf                <S0232.LIB>

SYNTAX: void Dreset_s0tbuf(void);

DESCRIPTION: Resets SIO channel 0 transmit buffer. Sets head and tail
indexes to zero.  Sets s0_tbufcnt to zero.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug void Dreset_s0tbuf(void)
{
    s0_tbufcnt = s0_tx_head = s0_tx_tail = 0;
}

/* START FUNCTION DESCRIPTION ********************************************
Dwrite_s0                    <S0232.LIB>

SYNTAX: int Dwrite_s0(char *buf, int count);

DESCRIPTION: Writes character data array of length "count" to transmit 
buffer.  "buf" points to character array.  "count" is number of char's 
to send.  Transmit interrupt is automatically turned on, if off.

RETURN VALUE: 1, if array is succesfully copied; 0, if there's no space
in transmit buffer for "count" characters.
END DESCRIPTION **********************************************************/
nodebug int Dwrite_s0(char *buf, int count)
{
    static char var;
    char mycheck;
    int  dum_tail, dum_head;
    int  i;

    if (!count) 
        return 1;            // No need to write anything
    
    if ((s0_tbufcnt + count) >= s0_tx_size) 
        return 0;

    dum_head = s0_tx_head;
    i = 0;
    do
    {
        *(s0_write_buf + dum_head++) = *(buf + i++);
        if (dum_head == s0_tx_size) 
            dum_head = 0; 
    } while (i < count);
    DI();           // disable interrupt, 5-3-94
    if (s0_tx_tail == s0_tx_head)
    {
        // 5-3-94 intoff(&var);
        s0_tx_head = dum_head;
        outport(SIOCA, 0x1); // enable transmitter interrupts
        outport(SIOCA, s0_wreg1 = s0_wreg1 | 2);
        // 5-3-94 doint();
        // Have to check transmit buffer, since device 
        // is not double buffered.
        outport(SIOCA, 0x00);
        if (inport(SIOCA) & '\B00000100')
        {
            s0_tbufcnt = count - 1;
            dum_tail = s0_tx_tail++; 
            if (s0_tx_tail == s0_tx_size) 
                s0_tx_tail = 0; 
            EI();       
            outport(SIODA, *(s0_write_buf + dum_tail)); // Send 1st char
        }
        else
        {
            s0_tbufcnt = count;
            EI();       // enable interrupt, 5-3-94 inton(&var);
        }
    }
    else
    {
        // 5-3-94 intoff(&var);
        s0_tx_head = dum_head;
        s0_tbufcnt = s0_tbufcnt + count;
        EI();       // enable interrupt, 5-3-94 inton(&var);
    }
    return 1;
}

/* START FUNCTION DESCRIPTION ********************************************
Dread_s0                     <S0232.LIB>

SYNTAX: int Dread_s0(char *buf, char terminate);

DESCRIPTION: Reads serial receive buffer for stream with specified 
terminate character.  "buf" points to user defined character array.
"terminate" is the terminating char of the stream, and is replaced by 
'\0'.  If modem option is selected with Dinit_s0(...), the receive 
stream is automatically parsed for modem messages.  The latter are 
automatically processed and serial service routines are called.  
Note that modem messages are terminated with 'CR'.

RETURN VALUE: 1, if stream is found and copied to buf; 0, if no stream 
is found or if modem option is selected and stream matched a modem message.
END DESCRIPTION **********************************************************/
nodebug int Dread_s0(char *buf, char terminate)
{
    int i;
    int dum_head, dum_tail;

    dum_head = s0_rx_head;
    dum_tail = s0_rx_tail;
    i = 0;

    if (dum_head == dum_tail) 
        return 0;
        
    do
    {
        *(buf + i) = *(s0_read_buf + dum_tail++);
        if (dum_tail == s0_rx_size) 
            dum_tail = 0;
        if (*(buf + i++) == terminate)
        {
            *(buf + i - 1) = '\0';
            s0_rx_tail = dum_tail;
            if (s0_CRTS_ENB)
            {
                s0_rbufcnt = s0_rbufcnt - i;
                if (! s0_CTS_ON)
                {
                    if (s0_rbufcnt <= s0_20rbuf)
                    {
                        s0_wreg5 = s0_wreg5 | 2;
                        outport(SIOCA, 0x05);
                        outport(SIOCA, s0_wreg5);
                        s0_CTS_ON = 1;
                    }
                }
            }

            if (s0UseModem)
            {
                if (Ds0modem_chk(buf) == -1) 
                    return 1;          // Not a modem msg
                else 
                    return 0;          // A modem msg
            }
            return 1;
        }
    } while (dum_tail != dum_head);    // 'til inbuf is empty
    return 0;
}

/* START FUNCTION DESCRIPTION ********************************************
Dwrite_s01ch                 <S0232.LIB>

SYNTAX: Dwrite_s01ch(char data);

DESCRIPTION: Writes a character to the transmit buffer.  Transmit 
interrupt is turned on, if off.

RETURN VALUE: 1, if data is succesfully written to transmit buffer;
0, if there's no space in buffer.
END DESCRIPTION **********************************************************/
nodebug int Dwrite_s01ch(char data)
{
    static char var;
    int dum_tail, dum_head;

    if ((s0_tbufcnt + 1) >= s0_tx_size) 
        return 0;
    dum_head = s0_tx_head;
    *(s0_write_buf + dum_head++) = data;
    if (dum_head == s0_tx_size) 
        dum_head = 0;
    DI();           // disable interrupt, 5-3-94
    if (s0_tx_tail == s0_tx_head)
    {
        // 5-3-94 intoff(&var);        // Disable interrupts, if on
        s0_tx_head = dum_head;
        outport(SIOCA, 0x1); // Enable transmitter interrupts
        outport(SIOCA, s0_wreg1 = s0_wreg1 | 2);
        // 5-3-94 doint();
        // Have to check the transmit buffer since the 
        // device is not double buffered.
        if (inport(SIOCA) & '\B00000100')
        {
            s0_tbufcnt = 0; 
            dum_tail = s0_tx_tail++; 
            if (s0_tx_tail == s0_tx_size) 
                s0_tx_tail = 0; 
            EI();               
            outport(SIODA, *(s0_write_buf + dum_tail)); // Send 1st char
        }
        else
        {
            s0_tbufcnt = 1;
            EI();           // enable interrupt,5-3-94 inton(&var);
        }
    }
    else
    {
        // 5-3-94 intoff(&var);   
        s0_tx_head = dum_head;
        s0_tbufcnt++;
        EI();       // enableinterrupt, 5-3-94 inton(&var);
    }
    return 1;
}

/* START FUNCTION DESCRIPTION ********************************************
Dread_s01ch                  <S0232.LIB>

SYNTAX: int Dread_s01ch(char *data);

DESCRIPTION: Reads serial receive buffer for a character.  "data" points
to a character.

RETURN VALUE: 1, if a byte is copied to *data; 0, if buffer is empty.
END DESCRIPTION **********************************************************/
nodebug int Dread_s01ch(char *data)
{
    int dum_head, dum_tail;

    dum_head = s0_rx_head;
    dum_tail = s0_rx_tail;

    if (dum_head == dum_tail) 
        return 0;
    else
    {
        *data = *(s0_read_buf + s0_rx_tail++);
        if (s0_rx_tail == s0_rx_size) 
            s0_rx_tail = 0;
        if (s0_CRTS_ENB)
        {
            s0_rbufcnt--;
            if (!s0_CTS_ON)
            {
                if (s0_rbufcnt <= s0_20rbuf)
                {
                    s0_wreg5 = s0_wreg5 | 2;
                    outport(SIOCA, 0x05);
                    outport(SIOCA, s0_wreg5);
                    s0_CTS_ON = 1;
                }
            }
        }
        return 1;
    }
}

/* START FUNCTION DESCRIPTION ********************************************
Dkill_s0                     <S0232.LIB>

SYNTAX: void Dkill_s0(void);

DESCRIPTION: Resets SIO channel 0.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug void Dkill_s0(void)
{
    static char var;

    intoff(&var);
    outport(SIOCA, 0x18);    // reset the channel
    outport(SIOCA, 0x18);
    inton(&var);
}

/* START FUNCTION DESCRIPTION ********************************************
Ds0_rser_int                 <S0232.LIB>

SYNTAX: Ds0_rser_int(void);

DESCRIPTION: Interrupt service routine for SIO channel 0 receive.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
#INT_VEC SIOAR_VEC Ds0_rser_int// Set interrupt vector
#INT_VEC SIOAER_VEC Ds0_rser_int// Special receive condition

#asm root nodebug 
Ds0_rser_int::
        push af
        push hl
        push bc
        push de

        ld a,0x30             ; reset error
        out0 (SIOCA),a
        in0 c,(SIODA)         ; get in character
        ld     a, (s0_data_mask)    ; 11-13-95, get the data mask
        and    c                    ; 11-13-95, mask the data
        ld     c, a                 ; 11-13-95, copy masked data to c
        ld a,(s0Binary)       ; binary mode ?
        cp 1
        jr z, _s0StuffData    ; just stuff in data if binary mode.
                       ; if text mode, process for BACKSPACE and echoing.
        ld a,c
        cp BACKSPACE          ; is character = BACKSPACE?
        jr nz, _s0notBackSpace
        ld a,(s0CmdOrData)
        cp 1
        jr z, _s0noEcho
        ld a,(s0_echo)
        cp 1
        jr nz,_s0noEcho
        out0 (SIODA),c        ; echo the character

_s0noEcho:
        ld de,(s0_rx_tail)    ; see if (rx_head) == (rx_tail)
        ld hl,(s0_rx_head)
        ld a,d
        cp h                  ;  if(rx_head)==(rx_tail) send a prompt '>'
        jr nz, _s0notHTR      ;
        ld a,e
        cp l
        jr nz, _s0notHTR
        jp _s0RcvTheEnd
_s0notHTR:
        ld a,h           ; if (rx_head)==0, (rx_head)=(rx_size) - 1;
        or l
        jr nz,_s0HeadnotZero
        ld hl,(s0_rx_size)
        dec hl
        ld (s0_rx_head),hl
        jp _decRbufcount

_s0HeadnotZero:
        ld hl,(s0_rx_head)  ; else (rx_head) = (rx_head) -1
        dec hl
        ld (s0_rx_head),hl
_decRbufcount:
        ld a,(s0_CRTS_ENB)
        cp 1
        jp nz,_s0RcvTheEnd
        ld hl, (s0_rbufcnt)
        dec hl
        ld (s0_rbufcnt),hl
        jp _s0RcvTheEnd

_s0notBackSpace:    ; not BACKSPACE, so push data into receive queue
        ld a,(s0CmdOrData)
        cp 1
        jr z, _s0StuffData
        ld a,(s0_echo)
        cp 1
        jr nz,_s0StuffData
        out0 (SIODA),c     ; echo character back
_s0StuffData:
; 1-26-96 Allow transmitter to overflow receiver beyond CTS not ready.
; 1-26-96        ld a,(s0_CTS_ON)
; 1-26-96        cp 1
; 1-26-96        jp nz, _s0RcvTheEnd
        ld de,(s0_read_buf)
        ld hl,(s0_rx_head)
        add hl,de
        ld (hl),c           ; store data
        ld de,(s0_rx_size)  ; do the modulo test
        ld hl,(s0_rx_head)
        inc hl
        ld a,d
        cp h                ; compare high byte
        jp nz,_s0notRollOver
        ld a,e
        cp l                ; compare low byte
        jp nz,_s0notRollOver
        ld hl,00
        ld (s0_rx_head),hl
        jp checkforCTS
 _s0notRollOver:
        ld (s0_rx_head),hl
 checkforCTS:
        ld a,(s0_CRTS_ENB)
        cp 1
        jp nz,_s0RcvTheEnd
        ld hl, (s0_rbufcnt)
        inc hl
        ld (s0_rbufcnt),hl
        ld de, (s0_80rbuf)
        ld a,e
        cp l
        jp nz, _s0RcvTheEnd
        ld a,d
        cp h
        jp nz, _s0RcvTheEnd
        ld a,0x05
        out0 (SIOCA),a
        ld a,(s0_wreg5)
        and 11111101b   ; turn off rts bit
        ld (s0_wreg5),a
        out0 (SIOCA),a
        ld a,0
        ld (s0_CTS_ON),a
 _s0RcvTheEnd:
        pop de
        pop bc
        pop hl
        pop af
        ei
        reti
#endasm

/* START FUNCTION DESCRIPTION ********************************************
Ds0_tser_int                 <S0232.LIB>

SYNTAX: Ds0_tser_int(void);

DESCRIPTION: Interrupt service routine for SIO channel 0 transmit.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
#INT_VEC SIOAT_VEC Ds0_tser_int// Set transmit interrupt vector
#asm root nodebug 
Ds0_tser_int::
        push af
        push hl
        push bc
        push de

        ld de,(s0_tx_head)   ; see if (tx_head) == (tx_tail)
        ld hl,(s0_tx_tail)
        ld a,d
        cp h        ; compare d to h
        jr nz, _nots0TxEnd
        ld a,e
        cp l
        jr nz, _nots0TxEnd
        ld a,0x11
        out0 (SIOCA),a
        ld a,(s0_wreg1)
        and 0xfd
        ld (s0_wreg1),a
        out0 (SIOCA),a
                     ; turn off interrupt when no more char's to send
        jp _s0TxTheEnd
 _nots0TxEnd:
        ld hl, (s0_tbufcnt)
        dec hl
        ld (s0_tbufcnt),hl
        ld de, (s0_write_buf)   ; send next character out
        ld hl, (s0_tx_tail)
        add hl,de
        ld c,(hl)
        out0 (SIODA),c
        ld de,(s0_tx_size)
        ld hl,(s0_tx_tail) ; do the modulo test
        inc hl
        ld a,d
        cp h             ; compare high byte
        jp nz,_nots0TRollOver
        ld a,e
        cp l
        jp nz,_nots0TRollOver
        ld hl,00
        ld (s0_tx_tail),hl
        jp _s0TxTheEnd
 _nots0TRollOver:
        ld (s0_tx_tail),hl
_s0TxTheEnd:
        pop de
        pop bc
        pop hl
        pop af
        ei
        reti
#endasm


#INT_VEC SIOAEX_VEC Ds0_stat_int // Status change, never happens
nodebug interrupt reti int Ds0_stat_int(void)
{
}

/* START FUNCTION DESCRIPTION ********************************************
Drestart_s0modem             <S0232.LIB>

SYNTAX: void Drestart_s0modem(void);

DESCRIPTION: Sends command to set/reset the modem connected to SI0, 
channel 0.  Hayes smart modem is desirable.  Required hardware 
connections:

                       MODEM               SIO CHAN 0
                        RX  ----------------- TX
                        TX  ----------------- RX
                        GND ----------------- GND
                        RTS --+           +-- RTS
                        CTS --|           +-- CTS
                        DTR --+

i.e. On modem side, RTS,CTS and DTR are tied together. On SCC side, 
RTS is connected to CTS.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug void Drestart_s0modem(void)
{
    int  ercode;
    int  ok_count;
    char buf[20];

    /* If modem is available, master should insure that
       modem is in command mode on power up.           */

    s0CmdOrData = 1;         // Modem in command mode
    ok_count = 0;
    Dwrite_s0("+++", 3);
    Ddelay_1sec();
    while ((++ok_count < 4) && ((ercode = Dread_s0(buf, ENTER)) == 0 ||
           (Dget_modem_command(buf) != 0))) 
        Ddelay_1sec();

    Dwrite_s0("AT H0", 5);   // Or time out
    Dwrite_s01ch(ENTER);
    ok_count = 0;
    while ((++ok_count < 4) && ((ercode = Dread_s0(buf, ENTER)) == 0 ||
           (Dget_modem_command(buf) != 0))) 
        Ddelay_1sec();       // Wait for OK

    Dwrite_s0("AT E0 V1 M0 S0=2", 16); // Or time out
    /*****************************
      E0 for commands not echoed
      V1 for word responses
      M0 for internal speaker off
      S0=2 for automatic answering
     ******************************/
    Dwrite_s01ch(ENTER);
    ok_count = 0;
    while ((++ok_count < 4) && ((ercode = Dread_s0(buf, ENTER)) == 0 ||
           (Dget_modem_command(buf) != 0))) 
        Ddelay_1sec();           // Wait for OK

    Dwrite_s0("AT &D0 &R1", 10); // or time out
    /********************************************
     &D0 for ignore the Data Terminal Ready (DTR)
     &R1 for ignore the Ready To Send (RTS)
     ********************************************/
    Dwrite_s01ch(ENTER);
    ok_count = 0;
    while ((++ok_count < 4) && ((ercode = Dread_s0(buf, ENTER)) == 0 ||
           (Dget_modem_command(buf) != 0))) 
        Ddelay_1sec();           // Wait for OK

    Ddelay_1sec();
    Dreset_s0rbuf();
}

/* START FUNCTION DESCRIPTION ********************************************
Ds0modem_chk                 <S0232.LIB>

SYNTAX: int Ds0modem_chk(char *buf);

DESCRIPTION: Checks 'CR' terminated stream for modem messages.  The serial 
service routines are called as function of modem condition (if selected).
"buf" points to a 'CR' terminated stream that was copied from the receive 
buffer.

RETURN VALUE: -1, if no match to any modem messages; 0, if stream was 
processed as a modem message.
END DESCRIPTION **********************************************************/
nodebug int Ds0modem_chk(char *buf)
{
    int which_one;
    int i;

    which_one = Dget_modem_command(buf);
    switch (which_one)
    {
        case -1: 
            if (!s0CmdOrData) 
                return - 1;
            break;
        case 2:         // Set for auto answer
                        // Dwrite_s0("ATA",3);
                        // Dwrite_s01ch(ENTER);
            break;      // Manually receive call if ring is detected
        case 9:
            Ddelay_5sec();
            Ddelay_5sec();
            Dreset_s0tbuf();
            Dreset_s0rbuf();
            s0CmdOrData = 0;
            Ds0send_prompt();
            Dwrite_s0("Welcome to the Remote System", 28);
            Ds0send_prompt();
            break;
                             // connect at 2400 bps
                             // Switch to data mode
        case 0:
            break;           // ok from command to modem
        case 3:
            s0CmdOrData = 1; // no carrier detect
            Ddelay_5sec();   // wait and reset buffers
            Dreset_s0tbuf();
            Dreset_s0rbuf();
            break;
        case 4:
            break;           // command error
        case 5:
            Ddelay_5sec();
            Ddelay_5sec();
            Dreset_s0tbuf();
            Dreset_s0rbuf();
            s0CmdOrData = 0;
            Ds0send_prompt();
            Dwrite_s0("Welcome to the Remote System", 28);
            Ds0send_prompt();
            break;           // Switch to data mode

        case 6:              // no dial tone
        case 7:              // busy
        case 8:              // no answer
        case 10:             // just line feed
        default:
            break;
    }
    return 0;
}

/*** BeginHeader Dxmodem_s0down, Dxmodem_s0up */

int Dxmodem_s0down(char *mydata, int n_blocks);
int Dxmodem_s0up(unsigned long baseAddress, int *no_of_pages, int dest,
    int (*data_parsing)() );

/*** EndHeader */
extern char s0Binary;       // 12-15-94 aoc

/* START FUNCTION DESCRIPTION ********************************************
Dxmodem_s0down               <S0232.LIB>

SYNTAX: int Dxmodem_s0down(char *mydata, int n_blocks);

DESCRIPTION: Sends blocks of data to PC or dumb terminal with xmodem 
file transfer protocol. "mydata" points to a character array.  n_blocks 
is the size of the array in 128-byte blocks.

RETURN VALUE: 0, if there's a timeout during transfer; 1, if transfer 
was successful; 2, if the transfer was cancelled.
END DESCRIPTION **********************************************************/
nodebug int Dxmodem_s0down(char *mydata, int n_blocks)
{
    int  i;
    int  timeout;
    unsigned char nth_block, not_nth;
    unsigned int testcrc;
    int  checksum;
    int  ercode;
    char cdata;
    int  iblock;

    nth_block = 1;
    not_nth   = ~nth_block;

    s0Binary = 1;
    timeout  = 0;
    Dwrite_s0("Ready to Download File", 22);
    Ds0send_prompt();
    Dwrite_s0("Do an xmodem receive", 20);
    Ds0send_prompt();
    while (((ercode = Dread_s01ch(&cdata)) == 0) || 
           ((cdata != XCRC) && (cdata != ESC) && (cdata != CAN)) )
    {
        Ddelay_1sec();
        if (++timeout >= 30)
        {
            s0Binary = 0;
            Ddelay_5sec();
            return 0;
        }
    }
    if (cdata == CAN || cdata == ESC) // monitor for a quick ABORT
    {
        s0Binary = 0;
        Ddelay_5sec();
        return 2;
    }
    else 
        timeout = 0;
    do
    {
        iblock = (nth_block - 1) * 128;
        Dwrite_s01ch(SOH);
        Dwrite_s01ch(nth_block);
        Dwrite_s01ch(not_nth);
        Dwrite_s0(mydata + iblock, 128);
        testcrc = getcrc(mydata + iblock, 128, 0);
        cdata = (testcrc >> 8) & 0xff;
        Dwrite_s01ch(cdata);
        cdata = testcrc & 0xff;
        Dwrite_s01ch(cdata);
        timeout = 0;
        while (((ercode = Dread_s01ch(&cdata)) == 0) ||
               ((cdata != XCRC) && (cdata != NAK) && 
                (cdata != ACK)  && (cdata != CAN)) )
        {
            Ddelay_1tick();
            if (++timeout > 200)
            {
                s0Binary = 0;
                Ddelay_5sec();
                return 0;
            }
        }
        if (cdata == CAN)
        {
            s0Binary = 0;
            Ddelay_5sec();
            return 2;
        }

        if (cdata == ACK)
        {
            if (++nth_block <= n_blocks) 
                not_nth = ~nth_block;
            else
            {
                Dwrite_s01ch(EOT);
                timeout = 0;
                while (((ercode = Dread_s01ch(&cdata)) == 0) || 
                         cdata != ACK )
                {
                    Ddelay_1tick();
                    if (++timeout > 200)
                    {
                        s0Binary = 0;
                        Ddelay_5sec();
                        return 0;
                    }
                };
                // Wait for final acknowledge for end of transfer
                // Time out, if necessary.
                s0Binary = 0;
                Ddelay_5sec();
                return 1;    // Return 1 for succesful transfer
            }
        }
    } while (1);
}

/* START FUNCTION DESCRIPTION ********************************************
Dxmodem_s0up                 <S0232.LIB>

SYNTAX: int Dxmodem_s0up(unsigned long baseAddress, int *no_of_pages, 
            int dest, int (*data_parsing)() );

DESCRIPTION: Uploads data from PC using xmodem file transfer protocol.
"baseAddress" is the destination's physical ram address.  "*no_of_pages" is 
the size of the uploaded file in number of pages.  "dest" is an additional 
parameter to locate the uploaded file.  "*data_parsing" is the address of 
the function to parse the uploaded file into memory.  The required parsing 
function prototype is:

int parse_function(char *mydata, int blockcount, 
    unsigned long baseAddress, int dest);

where "mydata" points to a 128 byte block of data;  "blockcount" is 
the nth block;  "baseAddress" is the base address of the uploaded file; and
"dest" is an added parameter to locate the data.  The parser function should 
return 1 for successful copy or else 0.

RETURN VALUE: 0, if there is a timeout during transfer; 1, if transfer 
was successful; 2, if transfer was cancelled.
END DESCRIPTION **********************************************************/
nodebug int Dxmodem_s0up(unsigned long baseAddress, int *no_of_pages, 
            int dest, int (*data_parsing)() )
{
    int  i;
    unsigned char nth_block, not_nth;
    unsigned int testcrc;
    unsigned int myblockcount;
    int  checksum;
    int  ercode;
    int  timeout;
    char cdata;
    char locrc, hicrc, mylocrc, myhicrc;
    char mydata[130];

    myblockcount = 1;
    s0Binary = 1;
    timeout  = 0;
    Dwrite_s0("Ready to receive", 16);
    Ds0send_prompt();
    Dwrite_s0("Xmodem File Up", 14);
    Ds0send_prompt();

    do
    {
        Dwrite_s01ch(XCRC);
        Ddelay_1sec();
        if (++timeout >= 30)
        {
            s0Binary = 0;
            Ddelay_5sec();
            return 0;
        }
    } while (((ercode = Dread_s01ch(&cdata)) == 0) || 
             ((cdata != SOH) && (cdata != ESC) && (cdata != CAN)) );
    
    if (cdata == CAN || cdata == ESC) // Somehow cancelled
    {
        s0Binary = 0;
        Ddelay_5sec();
        return 2;
    }

    do
    {
        timeout = 0;
        while (++timeout < 100 && (ercode = Dread_s01ch(&cdata) == 0)) 
            Ddelay_1tick();
        if (timeout >= 100)
        {
            s0Binary = 0;
            Ddelay_5sec();
            return 0;
        }
        else 
            nth_block = cdata;
        timeout = 0;
        while (++timeout < 100 && (ercode = Dread_s01ch(&cdata) == 0)) 
            Ddelay_1tick();
        if (timeout >= 100)
        {
            s0Binary = 0;
            Ddelay_5sec();
            return 0;
        }
        else 
            not_nth = cdata;

        checksum = 0;
        timeout = 0;
        for (i = 0; i < 128; i++)
        {
            while (++timeout < 100 && (ercode = Dread_s01ch(&cdata)) == 0) 
                Ddelay_1tick();

            if (timeout >= 100)
            {
                s0Binary = 0;
                Ddelay_5sec();
                return 0;
            }
            else
            {
                timeout = 0;
                mydata[i] = cdata;
            }
        }
        testcrc = getcrc(mydata, 128, 0);
        myhicrc = (testcrc >> 8) & 0xff;
        mylocrc = testcrc & 0xff;
        timeout = 0;
        while (++timeout <= 100 && (ercode = Dread_s01ch(&cdata) == 0)) 
            Ddelay_1tick();
        if (timeout >= 100)
        {
            s0Binary = 0;
            Ddelay_5sec();
            return 0;
        }
        else 
            hicrc = cdata;

        timeout = 0;
        while (++timeout <= 100 && (ercode = Dread_s01ch(&cdata) == 0)) 
            Ddelay_1tick();

        if (timeout >= 100)
        {
            s0Binary = 0;
            Ddelay_5sec();
            return 0;
        }
        else
        {
            if (cdata == mylocrc && hicrc == myhicrc)
            {
                if ((*data_parsing)(mydata, myblockcount, 
                    baseAddress, dest) == 1)
                {
                    Dwrite_s01ch(ACK);
                    ++myblockcount;
                }
                else 
                    Dwrite_s01ch(XCRC); 
            }
            else 
                Dwrite_s01ch(XCRC); 
        }
        timeout = 0;
        while (((ercode = Dread_s01ch(&cdata)) == 0) ||
                ((cdata != EOT) && (cdata != SOH) && (cdata != CAN)))
        {
            Ddelay_1tick();
            if (++timeout > 100) // Time out after 2-3 secs
            {
                s0Binary = 0;
                Ddelay_5sec();
                return 0;
            }
        }
        if (cdata == EOT)
        {
            Dwrite_s01ch(ACK);
            s0Binary = 0;
            *no_of_pages = myblockcount / 32;
            Ddelay_5sec();
            return 1;        // Return 1 for successfull transfer
        }
        if (cdata == CAN)
        {
            s0Binary = 0;
            Ddelay_5sec();
            return 2;
        }
    } while (1);
}


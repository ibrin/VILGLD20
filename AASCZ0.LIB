/*
aascz0.lib
*/

/*** BeginHeader z0Init,z0Close */

#use aasc.lib

// This is the number of zeros that must be received
// for the interrupt to decide that a break request was issued
// This may need to be bumped for some modem setups

#define USE_Z0 1

#ifndef ASCI_PARAM_TIE

#define N_ZEROS_FOR_BREQ 25
#define ASCI_PARAM_TIE 0x01
#define ASCI_PARAM_RIE 0x08
#define ASCI_PARAM_CRTS 0x100000
#define ASCI_PARAM_TE 0x200000
#define ASCI_PARAM_RE 0x400000
#define ASCI_PARAM_MPE 0x800000
#define ASCI_PARAM_EFR 0x080000
#define ASCI_PARAM_8D 0x040000
#define ASCI_PARAM_7D 0x000000
#define ASCI_PARAM_EPARITY 0x00020000
#define ASCI_PARAM_OPARITY 0x00020000
#define ASCI_PARAM_NOPARITY 0x000000
#define ASCI_PARAM_1STOP 0x000000
#define ASCI_PARAM_2STOP 0x010000
#define ASCI_PARAM_MPBT 0x80000000
#define ASCI_PARAM_MP 0x40000000
#define ASCI_PARAM_CTSPS 0x20000000
#define ASCI_PARAM_PEO 0x10000000
#define ASCI_PARAM_DR64 0x08000000
#define ASCI_PARAM_1200 0x0100
#define ASCI_PARAM_8N1 0x040000

#endif

void z0Init(long Param, char CRTS, struct _Channel * Channel,void(*brqfnc)(),int reopen);
void z0Close(struct _Channel *pChan);
void z0TxSwitch(char OnOff, struct _Channel *pChan);
void z0RxSwitch(char OnOff, struct _Channel *pChan);
void _z0Int();
extern long z0Error;
extern int z0BrCount;
unsigned z0BRFnc;
#asm
dum: equ z0Init
#endasm

/*** EndHeader */

#define ASCI_TE '\B00100000'
#define ASCI_RE '\B01000000'
#define ASCI_9TH '\B10000000'
#define ASCI_CRTS '\B00010000'
#define ASCI_MPBT '\B10000000'
#define ASCI_RDRF '\B10000000'
#define ASCI_OVRN '\B01000000'
#define ASCI_PE '\B00100000'
#define ASCI_FE '\B00010000'
#define ASCI_TDRE '\B00000010'
#define ASCI_TIE '\B00000001'
#define ASCI_RIE '\B00001000'
#define ASCI_EFR '\B00001000'

#define ASCI_ERROR_INOVR 0x0100

struct _CircBuffer *pZ0InBuf, *pZ0OutBuf;
long z0Error;
int z0BrCount;
char z0CRTS;

/* START FUNCTION DESCRIPTION ********************************************
z0Init                       <AASCZ0.LIB>

SYNTAX:	void z0Init(long Param, char CRTS, struct _Channel * Channel);

DESCRIPTION:        Initializes the z0 device.  The z0 device is the ASCI
built-in on the Z180.  Param is a long integer specifying the initialization
attributes of the device, and Channel is the assigned channel for the device.
The device needs a logical channel to operate.

RETURN VALUE:       None.

END DESCRIPTION **********************************************************/

root void z0Init(long Param, char CRTS,
		struct _Channel * Channel,void(*brqfnc)(),int reopen) {
	auto char stat, baud, cntla0, cntlb0;
	segchain _aascInitDF {
		DevFunc[DEV_Z0].DevOpen = z0Init;
		DevFunc[DEV_Z0].DevClose = z0Close;
		DevFunc[DEV_Z0].TxSwitch = z0TxSwitch;
		DevFunc[DEV_Z0].RxSwitch = z0RxSwitch;
		DevFunc[DEV_Z0].DevGetError = z0GetErr;
		DevFunc[DEV_Z0].DevClrError = z0ClrErr;
	}
	segchain _aascInitDF_DLP {
	  	xmem2root( aascGetDLMChan(),&DevFunc[DEV_Z0],12);
	}
	z0BrCount = 0;
	Param |= (CRTS ? ASCI_PARAM_CRTS : 0);

	if(!reopen)z0BRFnc = (unsigned)brqfnc;	
	stat = *((char*)&Param);
	baud = *((char*)&Param+1);
	cntla0 = *((char*)&Param+2);
	cntlb0 = *((char*)&Param+3);
	
    outport(STAT0, 0);       // reset port
    outport(CNTLB0, (z180baud(sysclock(), baud) | cntlb0));
    outport(CNTLA0, (cntla0 | 0x60) & (~ASCI_CRTS)&
    	(~(ASCI_TE | ASCI_RE)));	//	turn off transmitter and receiver
    inport(RDR0);
    inport(RDR0);
    outport(STAT0, stat&(~(ASCI_TIE|ASCI_RIE)));
    	//	turn off transmitter and receiver interrupt
    pZ0InBuf = Channel->InBuf;
    pZ0OutBuf = Channel->OutBuf;
    z0Error = 0;
    z0CRTS = (Param & ASCI_PARAM_CRTS) ? ASCI_CRTS : 0;
		         // set baud rate, odd or even parity
#if ROM==0
	if(!reopen)reload_vec(SER0_VEC,_z0Int);
#endif
	}

/* START FUNCTION DESCRIPTION ********************************************
z0Close                      <AASCZ0.LIB>

SYNTAX:                       void z0Close()

DESCRIPTION:        Closes down the Z0 device.

RETURN VALUE:       None.
		
END DESCRIPTION **********************************************************/

root void z0Close(struct _Channel *pChan) {
	z0TxSwitch(0,pChan);
	z0RxSwitch(0,pChan);
    pZ0InBuf = NULL;
    pZ0OutBuf = NULL;
    z0Error = 0;
	}

/* START FUNCTION DESCRIPTION ********************************************
z0TxSwitch                   <AASCZ0.LIB>

SYNTAX:                       void z0TxSwitch(char OnOff);

DESCRIPTION:        Turns the transmitter on and off.  Also turns on and turn
off the transmit interrupt on and off.

RETURN VALUE:

END DESCRIPTION **********************************************************/

root void z0TxSwitch(char OnOff, struct _Channel *pChan) {
	outport(CNTLA0,OnOff?
							(inport(CNTLA0)|ASCI_TE):
							(inport(CNTLA0)&(~ASCI_TE)));           //        transmit enable
	outport(STAT0,OnOff?
							(inport(STAT0)|ASCI_TIE):
							(inport(STAT0)&(~ASCI_TIE))); //        transmit int enable
//        if (OnOff) EI();
	}

/* START FUNCTION DESCRIPTION ********************************************
z0RxSwitch                   <AASCZ0.LIB>

SYNTAX:		void z0RxSwitch(char OnOff, struct _Channel * pChan)

DESCRIPTION:        Turns the receiver On and off.  Also turns on/off the
receiver interrupt.  If C/RTS is specified when the device is opened,
turning off the receiver also turns on CTS (therefore turning off the
remote transmitter).  If CRTS is non-zero, turning off the receiver
also disables the remote transmitter, turning on the receiver reenables
the remote transmitter.

RETURN VALUE:       None.

END DESCRIPTION **********************************************************/

root void z0RxSwitch(char OnOff, struct _Channel *pChan) {
	//	receive enable
	outport(CNTLA0, OnOff ?
							((pChan->CRTS ? (~ASCI_CRTS) : 0xff) & (inport(CNTLA0)|ASCI_RE)):
							((pChan->CRTS ? ASCI_CRTS : 0) | (inport(CNTLA0)&(~ASCI_RE))));
							
	outport(STAT0,OnOff?
							(inport(STAT0)|ASCI_RIE):
							(inport(STAT0)&(~ASCI_RIE)));
	if (OnOff) EI();
	}

char _z0IntChar;
	
/* START FUNCTION DESCRIPTION ********************************************
_z0Int                       <AASCZ0.LIB>

SYNTAX:                       void _z0Int();

DESCRIPTION:        This is the interrupt handler of the device.  Can handle
57600bps with a 9MHz Z180.

RETURN VALUE:       None.

END DESCRIPTION **********************************************************/

#if ROM != 0
#INT_VEC  SER0_VEC _z0Int
#endif

#asm fast
_z0Int::
	push      ix
	push      iy
	push      af
	push      bc
	push      de
	push      hl        ;         save registers to be used
	
	in0       b,(STAT0) ;         b is STAT0
	bit       7,b
	jr        z,z0Int0100

	; 	byte ready for reading
	push      bc       ;         saves b on the stack
	ld        d,0
	in0       e,(RDR0)
	push      de
	ld        hl,(pZ0InBuf)
	push      hl
	call      circbufPutByte
	pop       de
	pop       de
	pop       bc                 ;         restores b from the stack
	ld        a,h
	or        l
	jr        nz,z0Int0050
	ld        hl,z0Error+1
	set       0,(hl)
	jr        z0Int0100           ;         continue to handle other cases
z0Int0050:
	ld        a,(z0CRTS)
	or        a
	jr        z,z0Int0100
	ld        hl,(pZ0InBuf)
	ld        de,1+_CircBuffer+Free
	add       hl,de
	ld        a,(hl)
	or        a
	jr        nz,z0Int0100
	dec       hl
	ld        a,(hl)
	cp        16
	jr        nc,z0Int0100
	;      						   z0CRTS != 0 and no more space
	;                   			time to turn on CTS
	in0       a,(CNTLA0)
	set       4,a
	out0      (CNTLA0),a
;         ld                  hl,z0Error+1
;         set       1,(hl)
;         ld                  a,b
;         res       3,a
;         out       (STAT0),a      ;         turn of read interrupt
	
z0Int0100:
	bit       1,b
	jr                  z,z0Int0200
	;                   ready to write another byte


	push      bc
	ld        hl,_z0IntChar
	push      hl
	ld        hl,(pZ0OutBuf)
	push      hl
	call      circbufGetByte
	pop       de
	pop       de
	pop       bc
	ld        a,h
	or        l
	jr        nz,z0Int0150
	;                   nothing to transmit, turn off TIE
	res       0,b
	out0      (STAT0),b
	jr        z0Int0200
z0Int0150:
	ld        a,(_z0IntChar)
	out0      (TDR0),a
z0Int0200:
	ld        a,b
	and       070h
	jr        z,z0Int0300
	;      				   some error occured
	ld        hl,z0Error
	or        (hl)
	ld        (hl),a

	; check for break request
	;     (framing error with N_ZEROS_FOR_BREQ 0's received)
	and       16			; framing error ?
	jr			 z,z0Int0240
	in0       e,(RDR0)
	xor		 a
	or			 e		 			; 0 received ?
	jr			 nz,z0Int0240
	ld        hl,z0BrCount
	inc		 (hl)
	ld 		 a,N_ZEROS_FOR_BREQ			
	cp 		 (hl)				; 0 recieved repeatedly ?
	jr			 nz,z0Int0250
	ld 		 hl,(z0BRFnc) 
	ld 		 a,l
	or			h
;	or 		 (hl)				; callback fnc. for Break Req defined ?
	jr			 z,z0Int0250
	di
	ld			 de,z0Int0240 	; push return address on stack
	push      de
	ld        hl,z0BrCount  ; zero out br count
	xor		 (hl)
	ld 		 hl,(z0BRFnc)
	jp 		 (hl)				; jump to callback
z0Int0240:
	ld        hl,z0BrCount  ; zero out br count
	xor		 (hl)
z0Int0250:

	in0       c,(CNTLA0)
	res       3,c
	out0      (CNTLA0),c
z0Int0300:
	pop       hl
	pop       de
	pop       bc
	pop       af
	pop       iy
	pop       ix
	ei
	ret
#endasm

void _z0DfaultBRQFnc(){

}

/*** BeginHeader z0GetErr */

long z0GetErr(struct _Channel *pChan);

/*** EndHeader */

long z0GetErr(struct _Channel *pChan) {
	return z0Error;
} 

/*** BeginHeader z0ClrErr */

void z0ClrErr(struct _Channel *pChan);

/*** EndHeader */

void z0ClrErr(struct _Channel *pChan) {
	z0Error = 0;
}

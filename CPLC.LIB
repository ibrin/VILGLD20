// 11-17-95 Change board type for board 8 to LittleG.
// 1-20-95
// Moved all Toshiba CLock routines to DRIVERS.LIB
// 12-1-94
// Change OUT1-OUT8 to OUTB1-OUTB8 for the LittleG.
// 11-29-94
// extern int SKEYR1, SKEYR2, SKEYR3, SKEYR4 should be
// extern char SKEYR1, SKEYR2, SKEYR3, SKEYR4.
// 11-4-94
// Added support for the 4x6 keypad for the Little Star and the Rugged Giant.
// To use do #define KEY4x6 in your code.
// 4x6 key pattern      19 20 21 22 23 24
//                      13 14 15 16 17 18
//                       7  8  9 10 11 12
//                       1  2  3  4  5  6

////1094 Added support for the LittleG. 
// 7-15-94 Added Support for the Z104 and Z104ISA boards.
// 7-15-94 Added support for 9Mhz Rugged Giant.
/* START LIBRARY DESCRIPTION *********************************************
CPLC.LIB
	 Copyright (c) 1994, Z-World.

DESCRIPTION: Support for the Rugged Giant (formerly the CPLC) and the 
Little Star.

SUPPORT LIB'S: sys.lib, drivers.lib
END DESCRIPTION **********************************************************/


/*** beginHeader */

#ifndef __CPLC_LIB
#define __CPLC_LIB

#ifdef __KDM_LIB
#error "CPLC.LIB cannot be used with KDM.LIB"
#endif

/*** EndHeader */

/*** Beginheader uplc_init */

#use vwdog.lib

void uplc_init(void);        // initialize Rugged Giant (CPLC)
									  // including interrupt driver
/*** Endheader */

/* START FUNCTION DESCRIPTION ********************************************
uplc_init                    <CPLC.LIB>

SYNTAX: void uplc_init(void);

KEYWORDS: init, driver, interrupt, timer, watchdog

DESCRIPTION: Initializes drivers and variables for the following: (a) 
Interrupt routine for background timer 1. (b) LCD, when selected. (c) 
keypad, if selected (keypad is scanned at 0.025ms). (d) virtual drivers, 
virtual timers and virtual watchdogs, when selected.  The timer 1 interrupt 
routine also services the watchdog timer.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug void uplc_init(void)
{
#if BOARD_TYPE==CPLC_BOARD
		  outport(DCNTL, 0x30);// Insert 3 I/O wait states.
		  up_beepvol(2);       // Set beep vloume to loud.
#endif
#if BOARD_TYPE == L_STAR
//    if(sysclock()==0x3c00) outport(DCNTL,0x30); // 3 io wait states @18.432mhz
//    else outport(DCNTL,0x00);   // no wait states at 9.216 mhz
		  outport(DMODE, 0xcd);// needed by the Little Star
		  outport(ITC, inport(ITC) & 0xf2); // make sure INT0 and INT2 are off
#endif

#if BOARD_TYPE == Z104ISA
		  outport(DMODE, 0xcd);
		  outport(ITC, inport(ITC) & 0xf2); // maske sure INT0 and INT2 are off

#endif

////1094
#if (BOARD_TYPE==LittleG)
		  outport(DCNTL, 0x30);   // insert 3 IO wait states
		  outport(ITC, inport(ITC) & 0xf3);   // make sure INT2 is off
#endif

	 _GLOBAL_INIT();           // Initialize all global inits.
#if ((BOARD_TYPE == L_STAR) || (BOARD_TYPE == CPLC_BOARD))
	 lc_init_keypad();        // Initialize keypad variables.
#endif
	 up_synctimer();          // Sink virtual time vairables with RTC.
#if (BOARD_TYPE==CPLC_BOARD) + (BOARD_TYPE==L_STAR)
#ifndef NOLCD
		  lcd_init_printf();   // Init the LCD if selected.
#endif
#endif

	sysPRT1_781();

#ifdef RUNKERNEL             // if real time kernel included
	init_kernel();
#endif

}

/* START FUNCTION DESCRIPTION ********************************************
lc_int_timer1                <CPLC.LIB>

SYNTAX: void lc_int_timer1(void);

KEYWORDS: timer, keypad, driver

DESCRIPTION: Interrupt service routine for timer 1. Includes services for 
keypad, virtual drivers and variables, beeper and the real time kernel.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/

#funcchain _sys_25msPostEI _lc_25ms

#ifndef N_WATCHDOG
#define N_WATCHDOG 0
#endif

#asm
_lc_25ms::
#ifndef __KDM_LIB

#if ((BOARD_TYPE==L_STAR) || (BOARD_TYPE == CPLC_BOARD))
; key not depressed timer lc_keycount
	 ld      hl,(lc_keycount)
	 inc     hl
	 ld      a,h
	 and     080h
	 jr      nz,timer2a1
	 ld      (lc_keycount),hl        ; counts up till reaches 0x8000
timer2a1:
#endif

#endif		//	ifndef __KDM_LIB

; step the second timer
;st_clk:
	 ei
#ifndef NOUNIVERSAL
	 call    VIODrvr     ; output drivers universal plc
#endif
;	 call    vwdog       ;vwdog
#ifndef NOTIMERS
	 call    vtimers     ; virtual timers
#endif
#ifdef UIBOARD_VDVR
	 call    ui_drivers  ; aoc, 5-18-93, virtual driver for ui board
#endif

#ifndef __KDM_LIB

#if BOARD_TYPE==CPLC_BOARD
	 ld      a,(SKEYR1)
	 push    af
	 ld      a,(SKEYR2)
	 push    af
	 ld      a,(SKEYR3)
	 push    af

;11-4-94,aoc
#ifdef KEY4x6
	 ld      a, (SKEYR4)
	 push    af
#endif
#endif		//	if BOARD_TYPE==CPLC_BOARD

#if ((BOARD_TYPE==L_STAR) || (BOARD_TYPE == CPLC_BOARD))
	call	lc_keybdtest
#endif

#if BOARD_TYPE==CPLC_BOARD
;11-4-94,aoc
#ifdef  KEY4x6
	 pop     af
	 ld      (SKEYR4), a
	 out0    (KEYR4), a
#endif


	 pop     af
	 ld      (SKEYR3),a
	 out0    (KEYR3),a
	 pop     af
	 ld      (SKEYR2),a
	 out0    (KEYR2),a
	 pop     af
	 ld      (SKEYR1),a
	 out0    (KEYR1),a

#endif		//	if BOARD_TYPE==CPLC_BOARD

#endif		//	ifndef __KDM_LIB

	 ret

; virtual timers
;   char T1I,T1PP,T1O;
;   shared int T1CNT,T1RLD;
; if TnI is true TnCNT counts down till zero then TnO goes true
; if TnI is false TnRLD is stored in TnCNT
vtimers:
	 ld      b,NV_TIMERS
	 ld      iy,T1I
vtim1:
	 ld      a,(IY)              ; get input
	 or      a
	 jr      z,vtim3a            ; if input false set output false
	 ld      a,(iy-1)            ; check previous input
	 or      a
	 jr      z,vtim3             ; if rising edge do reload
; else count
	 ld      l,(iy-4)
	 ld      h,(iy-3)            ; get counter
	 ld      a,l
	 or      h
	 jr      z,vtim2             ; if counter is zero
	 dec     hl
	 di
	 ld      (iy-4),l
	 ld      (iy-3),h  ; restore counter, int off in case someone reads it
	 ei
vtim2:
	 ld      a,l
	 or      h
	 jr      nz, vtim2a
	 ld      (iy-2),1                ; enable output if timer is zero
vtim2a:
	 jr      vtim4
; here if input is false or rising edge
vtim3:
	 di
	 ld      a,(iy-6)
	 ld      (iy-4),a
	 ld      a,(iy-5)
	 ld      (iy-3),a                ; transfer reload value
	 ei
vtim3a:
	 ld      (iy-2),0                ; set output zero
vtim4:
	 ld      a,(iy)                  ; input
	 ld      (iy-1),a                ; set to TnPP previous input
	 ld      de,7
	 add     iy,de
	 djnz    vtim1
	 ret

#endasm

/*** Beginheader  */    

#define NV_TIMERS 10

	 char T10I, T10PP, T10O;
	 shared int T10CNT,T10RLD;
	 char T9I,  T9PP,  T9O;
	 shared int T9CNT, T9RLD;
	 char T8I,  T8PP,  T8O;
	 shared int T8CNT, T8RLD;
	 char T7I,  T7PP,  T7O;
	 shared int T7CNT, T7RLD;
	 char T6I,  T6PP,  T6O;
	 shared int T6CNT, T6RLD;
	 char T5I,  T5PP,  T5O;
	 shared int T5CNT, T5RLD;
	 char T4I,  T4PP,  T4O;
	 shared int T4CNT, T4RLD;
	 char T3I,  T3PP,  T3O;
	 shared int T3CNT, T3RLD;
	 char T2I,  T2PP,  T2O;
	 shared int T2CNT, T2RLD;
	 char T1I,  T1PP,  T1O;
	 shared int T1CNT, T1RLD;

	 // millisecond and second timers
	 shared int stacker;


/* START FUNCTION DESCRIPTION ********************************************
type_55_init.cplc                 <CPLC.LIB>

SYNTAX: int type_55_init(void);

KEYWORDS: init

DESCRIPTION: Dummy function to accomodate GLOBAL_INIT of variables.
RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug void type_55_init(void)
{
	 char *p;
	 int  k, j;

#GLOBAL_INIT
	 {
		  p = &T1O;
		  for (k = 0; k<NV_TIMERS; k++) // clear counter inputs    
		  {
				*p++= 0;
				*p++= 0;
				*p = 0;
				p = p + 5;
		  }

		  MS_TIMER = 0L;
		  MS_TIMEL = 0;
		  SEC_TIMEL = SEC_TIMER = 0L;
		  p = (char *) &SEC_TIMEI;
		  k = 0x16C;       // pointer to increment in eeprom
				for (j = 0; j < 4; j++)
					 *p++= ee_rd(k++);

		  if (SEC_TIMEI < 107000000L || SEC_TIMEI > 107600000L)
		  {
				SEC_TIMEI = 107374182L; // initialize timers in case of
												// bad eeprom values.
		  }
	 }
}

/*** Endheader */


/*** BeginHeader lc_kxinit,lc_kxkey,lc_beepvol */

int lc_kxget(char mode);     // mode=0, check, get and remove key
									  // mode=1, check and get key
void lc_kxinit(void);        // initialize keypad/beeper interrupt
// note: set optionally RUNKERNEL and LK_FASTCALL preprocessor vars
void lc_setbeep(int count);  // beep for number of 400 Hz cycles specified
void up_beep(unsigned int milliseconds); // beep for n milliseconds
void lc_loadtab(int *tab, int tab_size);
void lc_settab(char flag);
unsigned int up_lastkey(void);   // number of ticks since last key

#if BOARD_TYPE==CPLC_BOARD
void up_beepvol(int vol);    // vol = 0, 1, 2 for increased volume
#endif

extern char lc_keyrpt;              // key repeat counter
extern char lc_fkeytestr, lc_keytestr,
	  lc_kxkey, lc_kxdead;
extern char lc_kxbuf[16], lc_kxinptr,
	  lc_kxoutptr;            // keystroke buffer
extern int  lc_beepvol;             // BEEPH or BEEPL for beep volume
extern shared unsigned int lc_keycount; // counts up to 32768
extern char lc_keyshadow;           // shadow for key register
extern char lc_usetab;              // tell to use table if not 24 keys
extern char lc_twokey;              // indicates 2 keys pressed

/*** Endheader */

char lc_keyrpt;              // key repeat counter
char lc_fkeytestr, lc_keytestr,
	  lc_kxkey, lc_kxdead;
char lc_kxbuf[16], lc_kxinptr,
	  lc_kxoutptr;            // keystroke buffer
int  lc_beepvol;             // BEEPH or BEEPL for beep volume
shared unsigned int lc_keycount; // counts up to 32768
char lc_keyshadow;           // shadow for key register
char lc_usetab;              // tell to use table if not 24 keys
char lc_twokey;              // indicates 2 keys pressed

#ifndef KEYPAD_SIZE
#define KEYPAD_SIZE 24
/* #define KEYPAD_SIZE 40 */

#endif

#ifndef N_WATCHDOG
#define N_WATCHDOG 0
#endif

int lc_tab[41];              // to hold key codes

int lc_24tab[] =
	 {
		  14, 22, 30, 38, 9, 17, 25, 33, 13, 21,
		  29, 37, 10, 18, 26, 34, 15, 23, 31, 39,
		  11, 19, 27, 35
	 };

int lc_16tab[] =
	 {
		  14, 9, 13, 10, 22, 17, 21, 18, 30, 25,
		  29, 26, 38, 33, 37, 34
	 };
//extern int SKEYR1, SKEYR2, SKEYR3, SKEYR4;    11-29-94
extern char SKEYR1, SKEYR2, SKEYR3, SKEYR4;     // 11-29-94, aoc

/* START FUNCTION DESCRIPTION ********************************************
lc_kxinit                    <CPLC.LIB>

SYNTAX: void lc_kxinit(void);

KEYWORDS: keypad, init, watchdog

DESCRIPTION: Initializes keypad driver and associated variables as well
as virtual watchdog variables.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug void lc_kxinit(void) 
{
	 int k;
									  // initialize keyboard I/O
	 lc_fkeytestr = 0;
									  // Set buffer empty:
	 lc_keytestr = lc_kxkey = lc_kxdead = lc_kxinptr = lc_kxoutptr = 0;
	 lc_beepcount = 0;
	 lc_keycount = 0;
	 lc_usetab = 0;
	 lc_twokey = 0;
	 if (KEYPAD_SIZE <= 24)
		  lc_loadtab(NULL, 0);

#if BOARD_TYPE==CPLC_BOARD
	 lc_beepvol = BEEPH;
	 SKEYR1 = SKEYR2 = SKEYR3 = 0; // shadow registers for keyregisters
	 outport(KEYR1, 0);
	 outport(KEYR2, 0);       // clear key register
	 outport(KEYR3, 0);       // used for jumper block

//11-4-94,aoc
#ifdef KEY4x6
	 SKEYR4 = 0;
	 outport(KEYR4, 0);
#endif

#endif

	vwdogInit(60);
}

/* START FUNCTION DESCRIPTION ********************************************
up_beepvol                   <CPLC.LIB>

SYNTAX: void up_beepvol(int vol);

KEYWORDS: beep

DESCRIPTION: Sets beeper volume. vol = 1 for low volume; 2 for hi volume.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
#if BOARD_TYPE==CPLC_BOARD
nodebug void up_beepvol(int vol)
{
	 if (vol)
	 {
		  if (vol == 1)
				lc_beepvol = BEEPL;
		  else
				lc_beepvol = BEEPH;
	 }
	 else
		  lc_beepvol = 0;
}
#endif

/* START FUNCTION DESCRIPTION ********************************************
lc_loadtab                   <CPLC.LIB>

SYNTAX: void lc_loadtab(int *tab, int tab_size);

KEYWORDS: lcd

DESCRIPTION: Load tab tables to match lcd screen.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug void lc_loadtab(int *tab, int tab_size)
{
	 int k;

	 if (tab == NULL)         // load table with default values
	 {
		  if (KEYPAD_SIZE == 24)
		  {
				for (k = 0; k < 24; ++k)
					 lc_tab[lc_24tab[k]] = k + 1;
		  }
		  else if (KEYPAD_SIZE == 16)
		  {
				for (k = 0; k < 16; ++k)
					 lc_tab[lc_16tab[k]] = k + 1;
		  }
		  else
		  {
				for (k = 0; k < 40; ++k)
					 lc_tab[k] = k + 1;
		  }
		  return;
	 }

	 if (tab_size > KEYPAD_SIZE)
		  tab_size = KEYPAD_SIZE;
	 if (tab_size > 40)
		  tab_size = 40;

	 if (KEYPAD_SIZE == 24)
	 {
		  for (k = 0; k < tab_size; ++k)
				lc_tab[lc_24tab[k]] = tab[k];
	 }
	 else
		  if (KEYPAD_SIZE == 16)
		  {
				for (k = 0; k < tab_size; ++k)
					 lc_tab[lc_16tab[k]] = tab[k];
		  }
		  else
		  {
				for (k = 0; k < tab_size; ++k)
					 lc_tab[k + 1] = tab[k];
				lc_usetab = 1;
		  }
}

/* START FUNCTION DESCRIPTION ********************************************
lc_settab                    <CPLC.LIB>

SYNTAX: void lc_settab(char flag);

KEYWORDS: lcd 

DESCRIPTION: Sets the tab variable lc_usetab.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug void lc_settab(char flag)
{
	 lc_usetab = flag;
}


/* START FUNCTION DESCRIPTION ********************************************
lc_kxget                     <CPLC.LIB>

SYNTAX: int lc_kxget(char mode);

KEYWORDS: keypad

DESCRIPTION: Fetches key value from FIFO keypad buffer.  If mode = 0,  
value is removed from buffer; else value remains in buffer.

RETURN VALUE: Key value or -1, if no key is available.
END DESCRIPTION **********************************************************/
nodebug int lc_kxget(char mode)
{
	 auto char temp;

	 if (lc_kxinptr == lc_kxoutptr)
		  return -1;          // if buffer empty, return -1

	 temp = lc_kxbuf[lc_kxoutptr];
	 if (!mode)
		  lc_kxoutptr = ++lc_kxoutptr & 0xf; // step circular buffer ptr
	 return temp;
}

/* START FUNCTION DESCRIPTION ********************************************
lc_setbeep                   <CPLC.LIB>

SYNTAX: void lc_setbeep(int delay);

KEYWORDS: beep

DESCRIPTION: Sets beeper duration for "delay" counts of 1280 Hz cycles.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
#asm nodebug
lc_setbeep::
		  ld      (lc_beepcount),hl
		  ret
#endasm

/* START FUNCTION DESCRIPTION ********************************************
up_beep                      <CPLC.LIB>

SYNTAX: void up_beep(unsigned int k);

KEYWORDS: beep

DESCRIPTION: Sets beeper on for k milliseconds.  

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug void up_beep(unsigned int k)
{                              // k in milliseconds, max=20000
#if BOARD_TYPE==CPLC_BOARD
		  lc_setbeep(k * 2 * 1.280);
										 // 2*1.280 is the number of millisecond
										 // per scan time (0.0003906 sec). The scan
										 // time for the CPLC is halved because the
										 // buzzer is software driven (on/off) every
										 // other scan time to generate the beeper
										 // sound.
#endif
#if BOARD_TYPE==L_STAR
		  outport(BUZZER, 0xff);
		  lc_setbeep(k * 1.280); // 1.280 is the number of millisecond per
										 // scan time ( 0.00078125 sec). Unlike the 
										 // CPLC, the Little Star's buzzer is self
										 // resonating.
#endif

#if BOARD_TYPE == Z104ISA
		  lc_setbeep(k * 1.280); // 1.280 is the number of milliseconds per
										 // scan time ( 0.00078125 sec).
		  outport(SPEAKER, 1);
#endif

}

/*************************************************************\
*   Routine to service timer 1 interrupt and drive beeper, keypad
*   If RUNKERNEL is defined, then the real time kernel is also called.
\**************************************************************/


/* returns time since last key in units of 1/40 sec
	max number returned is 0x8000 or 32768 */
/* START FUNCTION DESCRIPTION ********************************************
up_lastkey                   <CPLC.LIB>

SYNTAX: unsigned int up_lastkey(void);

KEYWORDS: keypad, time

DESCRIPTION: Returns time since last key was pressed, in units of 1/40 sec.

RETURN VALUE: Lapsed time.
END DESCRIPTION **********************************************************/
nodebug unsigned int up_lastkey(void)
{
	 return lc_keycount;
}

#ifdef RUNKERNEL
interrupt int dotimer1(void)
{
	run_timer();              // call real time kernel
}
#endif

/*** BeginHeader lc_init_keypad */

void lc_init_keypad(void);

/*** EndHeader  */



/* START FUNCTION DESCRIPTION ********************************************
lc_init_keypad               <CPLC.LIB>

SYNTAX: void lc_init_keypad(void);

KEYWORDS: init, timer, keypad, realtime

DESCRIPTION: Initializes timer1, keypad driver and variables and the 
real time kernel.

RETURN VALUE: None.
END DESCRIPTION **********************************************************/
nodebug void lc_init_keypad(void)
{
	 int k;
	 
	 if (iff())
	 {
		  DI();
		  k = 1;               // reverse sequence to avoid INT conflict
	 }
	 else 
		  k = 0;

	 lc_kxinit();             //  initialize the keyboard input queue

	 if (k)
		  EI();
}


/*** BeginHeader up_synctimer */

int up_synctimer(void);

/*** Endheader */

/* call with SEC_TIMER ticking every second */
/* START FUNCTION DESCRIPTION ********************************************
up_synctimer                 <CPLC.LIB>

SYNTAX: int up_synctimer(void);

KEYWORDS: clock

DESCRIPTION: Synchronize the virtual SEC_TIMER with the RTC.

RETURN VALUE: 0, if RTC is read properly; else -1.
END DESCRIPTION **********************************************************/
nodebug int up_synctimer(void)
{
	 int           i, j;
	 unsigned long k;
	 struct tm     synctm;

	 // Read time until it ticks or there's an error
	 i = 0;
	 
	 tm_rd(&synctm);		//	changed to tm_rd from tmc_rd due to new RTC

	 i = synctm.tm_sec;
	 k = SEC_TIMER;
	 while ((SEC_TIMER - k) < 2)
	 {
		  j = tm_rd(&synctm);    // get time, changed to tm_rd from tmc_rd

		  if (i != synctm.tm_sec)
		  {
				SEC_TIMER = mktime(&synctm);
				return 0;
		  }
		  if (j < 0)
				break;
	 }
	 return -1;
}



/*** BeginHeader lc_keybdtest */

void lc_keybdtest();

/*** EndHeader */

#asm
lc_keybdtest::
	call brdChkKB
	jr	nz,kbtest2
kbtest1aa:
	call	brdQuitChkKB
	 ld      a,(lc_kxkey)
	 or      a
	 ret     z       ; if lc_kxkey ==0 and code==0 noactivity
						  ; come here if previous key not yet flushed from system
kbtest1a:           ; here to process counting dead time
	 ld      a,(lc_kxdead)
	 or      a
	 jr      nz,kbtest1b
	 xor     a               ; zero previous key after deadtime expires
	 ld      (lc_kxkey),a    ; done process on key after dead time expires
	 ret
kbtest1b:
	 dec     a
	 ld      (lc_kxdead),a   ; step dead time count
	 ret
				; here a code was detected on keyboard, L has bit, H is 0 or 1

kbtest2:
	call brdResKB
	 call    kbcvt           ; convert to 6 bit code in a
	 ld      hl,lc_kxkey     ; equal to previous key?
	 cp      (hl)            ; is this code a key holding?
	 jr      nz,kbtest2a
	 jr      kbtest2b
							; here key is a fresh key
kbtest2a:
	 ld      hl,lc_twokey
	 ld      (hl),0         ; 2 key must hold until stopper energized
	 ld      hl,lc_keyrpt
	 ld      (hl),35       ; 2/3 second before repeat function starts
	 ld      hl,lc_kxkey
	 jr      kbtest2c       ; go get first instance of key

kbtest2b:
; here key is holding
	 ld      hl,lc_keyrpt
	 dec     (hl)
	 ret     nz              ; if repeat time not expired
	 ld      (hl),9          ; further repeat times .18 second every 9 ticks
	 ld      hl,lc_kxkey     ; restore hl
	 ld      (hl),0          ; make the old key vanish, 
									 ; so this treated as  new key

								; here make sure new key found and dead time expired
kbtest2c:
	 push    af
	 ld      a,(hl)
	 or      a                 ; is kxcode==0?
	 jr      z,kbtest4         ; new key
	 pop     af
	 jr      kbtest1a          ; go count out dead time
; here new key definitely detected
kbtest4:
	 pop     af
	 ld      (hl),a            ; save new key value
	 call    kxput             ; put key in output circular buffer
; further key pushes not recognized until dead time expires
	 ld      a,3
	 ld      (lc_kxdead),a     ; set dead time count
	 ret
; place next keystroke into output buffer
kxput:
	 push    af                ; save keycode
	 ld      hl,0
	 ld      (lc_keycount),hl  ; clear keycount
	 ld      a,(lc_kxinptr)
	 ld      hl,lc_kxoutptr
	 inc     a
	 and     0fh
	 cp      (hl)              ; inptr+1 == outptr??
	 jr      z,kxovfl          ; buffer full
	 ld      h,a               ; new buffer
	 ld      a,(lc_kxinptr)
	 ld      l,a
	 ld      a,h               ;new buf
	 ld      (lc_kxinptr),a    ; save updated buf ptr
	 ld      h,0
	 ld      bc,lc_kxbuf
	 add     hl,bc             ; address in buffer
	 pop     af                ;keycode
	 ld      (hl),a            ;save it
#ifdef KEYREQUEST
#ifdef RUNKERNEL
	 ld      hl,KEYREQUEST       ; task to run
	 push    hl
	 call    request     ; run a kernel routine to process key received
	 pop     hl
#endif
#endif
	 ret

kxovfl:
	 pop     af            ; pop af from caller, aoc 5-13-93
#if BOARD_TYPE==CPLC_BOARD
	 ld      hl,500
#endif

#if BOARD_TYPE==L_STAR
	 ld      bc,BUZZER
	 ld      a,0xff
	 out     (c),a           ; turn on buzzer
	 ld      hl,250
#endif
	
#if BOARD_TYPE==Z104ISA   
	 ld      hl, 0
#endif    

;;;;1094
#if (BOARD_TYPE==LittleG)
	 ld      hl, 0
#endif


	 ld      (lc_beepcount),hl ; make a long beep
	 ret


; convert raw codes in hl to 6 bit code in a
kbcvt:
	 xor     a                   ; clear C
	 ld      a,l                 ; 6 bits
	 ld      b,6
kbcvt1:
	 rl      a                   ; set zero too
	 jr      c,kbcvt2
	 djnz    kbcvt1
kbcvt2:
	 push    hl
	 jr      z,kbctt2b           ; if not more than 1 key
	 ld      a,h                 ; row, 0 or 1
	 or      a
	 jr      z,kbctt2b           ; two key detection only top row
	 bit     7,l
	 jr      z,kbctt2b           ; first key most be one for 2 key detection
	 ld      hl,lc_twokey
	 inc     (hl)
	 jr      kbctt2c
kbctt2b:
	 ld      hl,lc_twokey
	 ld      (hl),0
	 jr      kbctt2d             ; continue
kbctt2c:
	 ld      a,10                ; if 2 keys down for 10 ticks
	 cp      a,(hl)
	 jr      nc,kbctt2d          ; if hl less
; stopper
; 2 keys depressed at same time, do a reset if watchdog enabled
#if BOARD_TYPE==CPLC_BOARD
	 in0     a,(UINP)
	 and     80h                 ; check watchdog jumper low, watchdog on
	 jr      nz,kbctt2d          ; ignore if watchdog not on
#endif

#if BOARD_TYPE==L_STAR
	 ld      bc, KROW3L
	 in      a,(c)           ; read the watchdog set pin
	 and     20h             ; only interested in the watchdog indicator pin
	 cp      20h             ; is it set?
	 jr      z,kbctt2d       ; jumper not on, do not force watchdog
#endif
	
#if BOARD_TYPE == Z104ISA
	 jr      kbctt2d
#endif
	
;;;; 1094   
#if (BOARD_TYPE==LittleG)
	 jr      kbctt2d
#endif

	di
stopper: jr    stopper

;11-4-94,aoc
#ifdef KEY4x6
kbctt2d:
	 pop     hl
	 ld      a, h
	 cp      3
	 jr      z, row4
	 cp      2
	 jr      z, row3
	 cp      1
	 jr      z, row2
row1:
	 jr      merge_row
row2:
	 ld      a, b
	 add     a, 6
	 ld      b, a
	 jr      merge_row
row3:
	 ld      a, b
	 add     a, 12
	 ld      b, a
	 jr      merge_row
row4:
	 ld      a, b
	 add     a, 18
	 ld      b, a
merge_row:
	 ld      a, 25
	 sub     a, b
	 ret
#else
kbctt2d:
	 pop     hl
	 ld      a,h
	 or      a
	 jr      z,kbcvt3

kbctt2a:
	 ld      a,b
	 add     a,6   ; second row
	 ld      b,a
kbcvt3:
	 ld      a,13
	 sub     a,b   ; the code 1-12
	 ret
#endif
#endasm

/*** BeginHeader */

#endif

/*** EndHeader */
